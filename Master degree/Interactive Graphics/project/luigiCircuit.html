<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Luigi Circuit</title>
        <link rel="icon" href="textures/mario_head.png" type="image/png" />

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #fps {
                position: absolute;
                background-color: green;
                border: 1px solid white;
                text-align: center;
                font-size: 16px;
                color: white;
                top: 15px;
                left: 10px;
                width: 60px;
                height: 20px;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    </head>

   <body>
    <div id="fps">0 fps</div>
    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
        // show fps
        var fps_interface = document.getElementById("fps");
        // better have some global variables to have them always available
        var car, car1, car2, car3, item;
        // front/rear left/right wheels for the user car
        var wheelFL, wheelFR, wheelRL, wheelRR;
        // arrays for the item boxes
        var itemBoxPos = [], itemBoxes = [];
        // arrays for 'negative' items
        var lethalItemPos = [], lethalItems = [];
        // arrays for 'positive' items
        var goodItemPos = [], goodItems = [];
        // arrays for the paths for the computer-controlled cars
        var points1 = [], points2 = [], points3 = [];

        var raceTime = 0;

        var groundMat, streetMat, bleachersMat;
        var update_done = false, game_ended = false;

        if(parent.document.URL.indexOf('&') > 1){
                var character_name = parent.document.URL.substring(parent.document.URL.indexOf('?')+11, parent.document.URL.indexOf('&'));
                var score = parseInt(parent.document.URL.substring(parent.document.URL.indexOf('&')+7, parent.document.URL.length));
        }
        else
            var character_name = parent.document.URL.substring(parent.document.URL.indexOf('?')+11, parent.document.URL.length);

        const createScene = () => {
            
            const scene = new BABYLON.Scene(engine);
            const camera = new BABYLON.FollowCamera("camera", new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            // in Luigi Circuit we have a sunlight: the most similar light in BabylonJS is the hemispheric light
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            // to simulate a strong yellowish light (i.e. Sun)
            light.diffuse = new BABYLON.Color3(1, 1, 0.85);
            light.specular = new BABYLON.Color3(1, 1, 0.75);
            // great light intensity for this open space
            light.intensity = 2;
            light.groundColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            
            // lighting - 1
            // ambient color requires the ambient color of the scene to be set
            scene.ambientColor = new BABYLON.Color3(1, 1, 1);

            // building the sky: Luigi Circuit race is during a sunny day :)
            // Sky material
            var skyboxMaterial = new BABYLON.SkyMaterial("skyMaterial", scene);
            skyboxMaterial.backFaceCulling = false;

            // Sky mesh (box)
            var skybox = BABYLON.Mesh.CreateBox("skyBox", 10000.0, scene);
            skybox.material = skyboxMaterial;

            var setSkyConfig = function (property, from, to) {
                var keys = [
                    { frame: 0, value: from },
                    { frame: 100, value: to }
                ];
                
                var animation = new BABYLON.Animation("animation", property, 100, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                animation.setKeys(keys);
                
                scene.stopAnimation(skybox);
                scene.beginDirectAnimation(skybox, [animation], 0, 100, false, 1);
            };
            // Set to Day
            setSkyConfig("material.inclination", skyboxMaterial.inclination, 0);

            // building the ground as the base of our environment
            groundMat = new BABYLON.StandardMaterial("groundMat");
            // lighting - a diffure texture for rendering the grass field is fine
            groundMat.diffuseTexture = new BABYLON.Texture("textures/grass.png");
            
            const ground = BABYLON.MeshBuilder.CreateDisc("ground", {radius: 650}, scene);
            ground.rotation.x = Math.PI / 2;
            ground.position.x = 325;
            ground.position.y = 0.49;
            ground.position.z = -60;
            ground.material = groundMat;

            // building the sand: here the car moves slower
            sandMat = new BABYLON.StandardMaterial("sandMat");
            sandMat.diffuseTexture = new BABYLON.Texture("textures/sand.png");

            const sand = BABYLON.MeshBuilder.CreateDisc("sand", {radius: 30}, scene);
            sand.rotation.x = Math.PI / 2;
            sand.position.x = 40;
            sand.position.y = 0.6;
            sand.position.z = 410;
            sand.material = sandMat;
            other_sand = sand.clone();
            other_sand.position.x = 60;
            other_sand.position.y = 0.65;
            other_sand.position.z = 420;

            other_sand = sand.clone();
            other_sand.position.x = 580;
            other_sand.position.z = 410;
            other_sand = sand.clone();
            other_sand.position.x = 560;
            other_sand.position.y = 0.65;
            other_sand.position.z = 420;

            other_sand = sand.clone();
            other_sand.position.x = 40;
            other_sand.position.z = -476;
            other_sand = sand.clone();
            other_sand.position.x = 60;
            other_sand.position.y = 0.65;
            other_sand.position.z = -486;

            other_sand = sand.clone();
            other_sand.position.x = 580;
            other_sand.position.z = -476;
            other_sand = sand.clone();
            other_sand.position.x = 560;
            other_sand.position.y = 0.65;
            other_sand.position.z = -486;

            // building the environment around the street
            // finish line
            BABYLON.SceneLoader.ImportMeshAsync("", "models/finish_line/", "scene.gltf", scene).then((result) => {
                finish = result.meshes[0];
                finish.scaling = new BABYLON.Vector3(-1.1, 0.8, 0.9);
                finish.position.y = -1;
                finish.position.x = 0;
                finish.position.z = 30;

                finish.rotation.y = Math.PI;
                finish.rotationQuaternion = null;

            });

            // walls
            BABYLON.SceneLoader.ImportMeshAsync("", "models/brick_block/", "scene.gltf", scene).then((result) => {
                wall = result.meshes[0];
                wall.scaling = new BABYLON.Vector3(0.015, 0.004, 0.002);
                wall.position.z = -440;
                wall.position.y = -0.3;
                wall.position.x = 15;
                wall.rotation.y = Math.PI/2;
                wall.rotationQuaternion = null;

                for(i=1; i<62; i++){
                    other_wall = this.wall.clone()
                    other_wall.position.z += i*13.1;
                }
                for(i=0; i<62; i++){
                    other_wall = this.wall.clone()
                    other_wall.position.x = -16;
                    other_wall.position.z += i*13.1;
                }

                for(i=0; i<62; i++){
                    other_wall = this.wall.clone()
                    other_wall.position.x = 603;
                    other_wall.position.z += i*13.1;
                }
                for(i=0; i<62; i++){
                    other_wall = this.wall.clone()
                    other_wall.position.x = 635;
                    other_wall.position.z += i*13.1;
                }

                for(i=0; i<31; i++){
                    other_wall = this.wall.clone()
                    other_wall.position.x = 115;
                    other_wall.position.z = -503.5;
                    other_wall.rotation.y = Math.PI;
                    other_wall.position.x += i*13.1;
                }

                for(i=0; i<31; i++){
                    other_wall = this.wall.clone()
                    other_wall.position.x = 115;
                    other_wall.position.z = 442;
                    other_wall.rotation.y = Math.PI;
                    other_wall.position.x += i*13.1;
                }
            });

            // plants
            BABYLON.SceneLoader.ImportMeshAsync("", "models/piranha_plant_small/", "scene.gltf", scene).then((result) => {
                plant = result.meshes[0];
                plant.scaling = new BABYLON.Vector3(0.01, 0.01, 0.01);
                plant.position.z = -430;
                plant.position.y = 3;
                plant.position.x = 15.5;
                plant.rotation.y = Math.PI/2;
                plant.rotationQuaternion = null;

                for(i=1; i<20; i++){
                    other_plant = this.plant.clone()
                    other_plant.position.z += i*40;
                }
                for(i=0; i<20; i++){
                    other_plant = this.plant.clone()
                    other_plant.position.x = -15.5;
                    other_plant.position.z += i*40;
                }

                for(i=0; i<20; i++){
                    other_plant = this.plant.clone()
                    other_plant.position.x = 603.5;
                    other_plant.position.z += i*40;
                }
                for(i=0; i<20; i++){
                    other_plant = this.plant.clone()
                    other_plant.position.x = 635.5;
                    other_plant.position.z += i*40;
                }
            });

            BABYLON.SceneLoader.ImportMeshAsync("", "models/piranha_plant_large/", "scene.gltf", scene).then((result) => {
                plant = result.meshes[0];
                plant.scaling = new BABYLON.Vector3(6.0, 6.0, 6.0);
                plant.position.z = 476;
                plant.position.y = -1.5;
                plant.position.x = 160;
                plant.rotation.y = Math.PI/2;
                plant.rotationQuaternion = null;

                for(i=1; i<4; i++){
                    other_plant = this.plant.clone()
                    other_plant.position.x += i*110;
                }
                for(i=0; i<4; i++){
                    other_plant = this.plant.clone()
                    plant.position.z = -540;
                    plant.rotation.y = Math.PI/2*3;
                    other_plant.position.x += i*110;
                }
            });

            // there was an easter egg but we decided to remove it :(
            // I'll leave this banana here as a memory.
            BABYLON.SceneLoader.ImportMeshAsync("", "models/banana/", "scene.gltf", scene).then((result) => {
                easter = result.meshes[0];
                easter.scaling = new BABYLON.Vector3(0.002, 0.002, 0.002);
                easter.position.y = 0.95;
                easter.position.z = 478;
                easter.position.x = 493;
            });

            // bleachers
            bleacherMat = new BABYLON.StandardMaterial("bleacherMat");
            bleacherMat.diffuseTexture = new BABYLON.Texture("textures/bleacher.png");
            bleacherMat.diffuseTexture.hasAlpha = true;
            
            const bleacher = BABYLON.MeshBuilder.CreateBox("bleacher", {width:6, height:6, depth:0.1});
            bleacher.rotation.y = Math.PI/180 *70;
            bleacher.position.x = 16;
            bleacher.position.z = 18;
            bleacher.position.y = 5.6;
            bleacher.material = bleacherMat;
            for (i=1; i<5; i++){
                other_bleacher = bleacher.clone();
                other_bleacher.position.z = 18+20*i;
            }
            for (i=0; i<5; i++){
                other_bleacher = bleacher.clone();
                other_bleacher.position.x = -16;
                other_bleacher.position.z = 18+20*i;
                other_bleacher.rotation.y = Math.PI/180 *290;
            }

            // castle
            BABYLON.SceneLoader.ImportMeshAsync("", "models/castle/", "scene.gltf", scene).then((result) => {
                castle = result.meshes[0];
                castle.scaling = new BABYLON.Vector3(0.02, 0.02, 0.02);
                castle.position.z = 450;
                castle.position.y = 0;
                castle.position.x = -10;
                castle.rotation.y = Math.PI/180*140;
                castle.rotationQuaternion = null;
            });

            // luigi in front of the castle
            BABYLON.SceneLoader.ImportMeshAsync("", "models/luigi/", "scene.gltf", scene).then((result) => {
                luigi = result.meshes[0];
                luigi.scaling = new BABYLON.Vector3(6.0, 6.0, 6.0);
                luigi.position.z = 420;
                luigi.position.y = 0.4;
                luigi.position.x = -10;
                luigi.rotation.y = Math.PI/180*160;
                luigi.rotationQuaternion = null;
            });

            // building the street
            streetMat = new BABYLON.StandardMaterial("streetMat");
            streetMat.diffuseTexture = new BABYLON.Texture("textures/road_luigi.png");
            streetMat.diffuseTexture.hasAlpha = true;
            
            const street = BABYLON.MeshBuilder.CreateBox("street", {width:30, height:60, depth:1});
            street.rotation.x = Math.PI / 2;
            street.material = streetMat;
            var pos_z = 60
            var pos_x = 10;
            for (i=0; i<6; i++){
                other_street = street.clone()
                other_street.position.z = pos_z;
                pos_z += 60;
            }
            
            // first curve: we divide it in 4 pieces with an incremental orientation
            const curve = BABYLON.MeshBuilder.CreateBox("street", {width:30, height:40, depth:1});
            curve.rotation.x = Math.PI / 2;
            curve.rotation.y = Math.PI / 9;
            curve.position.y = 0.05;
            curve.position.z = pos_z-17;
            curve.position.x = pos_x-4;
            pos_z += 14;
            pos_x += 13;
            angle = 2*Math.PI / 9;
            curve.material = streetMat;
            for (i=0; i<2; i++){
                other_curve = curve.clone();
                other_curve.rotation.y = angle;
                other_curve.position.z = pos_z;
                other_curve.position.x = pos_x;
                other_curve.position.y += 0.01*(i+1);
                pos_z += 18;
                pos_x += 28;
                angle += Math.PI / 6;   
            }

            // second 'rettilineo' of other pieces of street
            pos_z -= 12;
            pos_x += 18;
            for (i=0; i<8; i++){
                other_street = street.clone()
                other_street.rotation.y = Math.PI / 2;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_x += 60;
            }

            // second curve: specular of the first one
            other_curve = curve.clone();
            other_curve.rotation.z += Math.PI / 2;
            other_curve.position.z = pos_z-7;
            other_curve.position.x = pos_x-15;
            other_curve.position.y += 0.01;
            pos_z -= 25;
            pos_x += 18;
            angle = 2*Math.PI / 9;
            for (i=0; i<2; i++){
                other_curve = curve.clone();
                other_curve.rotation.z += Math.PI / 2;
                other_curve.rotation.y = angle;
                other_curve.position.z = pos_z;
                other_curve.position.x = pos_x;
                other_curve.position.y += 0.01*(i+2);
                pos_z -= 28;
                pos_x += 20;
                angle += Math.PI / 6;   
            }

            // third straight line (greater than the previous one)
            pos_z -= 15;
            pos_x -= 15;
            for (i=0; i<14; i++){
                other_street = street.clone()
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_z -= 60;
            }

            // third curve
            other_curve = curve.clone();
            other_curve.rotation.z += Math.PI;
            other_curve.position.z = pos_z+15;
            other_curve.position.x = pos_x-6;
            other_curve.position.y += 0.01;
            pos_z -= 15;
            pos_x -= 23;
            angle = 2*Math.PI / 9;
            for (i=0; i<2; i++){
                other_curve = curve.clone();
                other_curve.rotation.z += Math.PI;
                other_curve.rotation.y = angle;
                other_curve.position.z = pos_z;
                other_curve.position.x = pos_x;
                other_curve.position.y += 0.01*(i+2);
                pos_z -= 20.5;
                pos_x -= 27.5;
                angle += Math.PI / 6;   
            }

            // forth straight line
            pos_z += 14;
            pos_x -= 18;
            for (i=0; i<8; i++){
                other_street = street.clone()
                other_street.rotation.y = Math.PI / 2;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_x -= 60;
            }

            // forth and last curve
            other_curve = curve.clone();
            other_curve.rotation.z -= Math.PI/2;
            other_curve.position.z = pos_z+6;
            other_curve.position.x = pos_x+14;
            other_curve.position.y += 0.01;
            pos_z += 24;
            pos_x -= 17;
            angle = 2*Math.PI / 9;
            for (i=0; i<2; i++){
                other_curve = curve.clone();
                other_curve.rotation.z -= Math.PI/2;
                other_curve.rotation.y = angle;
                other_curve.position.z = pos_z;
                other_curve.position.x = pos_x;
                other_curve.position.y += 0.01*(i+2);
                pos_z += 26;
                pos_x -= 20;
                angle += Math.PI / 6;   
            }

            // fifth and last straight line
            pos_z += 20;
            pos_x += 13;
            for (i=0; i<6; i++){
                other_street = street.clone();
                other_street.rotation.y = Math.PI;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_z += 60;
            }
            // add a last piece to nicely end the circuit
            other_street = BABYLON.MeshBuilder.CreateBox("street", {width:30, height:64, depth:1});
            other_street.rotation.x = Math.PI / 2;
            other_street.material = streetMat;
            other_street.position.z = pos_z+2;
            other_street.position.x = pos_x;
            
            // user's car
            if(character_name == 'mario')
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_mario/", "scene.gltf", scene).then((result) => {
                    car = result.meshes[0];
                    car.scaling = new BABYLON.Vector3(2.2, 2.2, -2.2);
                    car.position.x = -5;
                    car.position.y = 0.7;
                    car.rotationQuaternion = null;
                    car.rotation.y = Math.PI;
                    // the camera will follow the car with this
                    camera.lockedTarget = car;

                    /*-----------------------Wheel------------------------------------------*/ 
	
                    // 'our' Wheel Material 
                    var wheelMaterial = new BABYLON.StandardMaterial("wheel_mat", scene);
                    var wheelTexture = new BABYLON.Texture("http://i.imgur.com/ZUWbT6L.png", scene);
                    wheelMaterial.diffuseTexture = wheelTexture;

                    //Set color for wheel tread as black
                    var faceColors=[];
                    faceColors[1] = new BABYLON.Color3(0,0,0);

                    //set texture for flat face of wheel 
                    var faceUV =[];
                    faceUV[0] = new BABYLON.Vector4(0,0,1,1);
                    faceUV[2] = new BABYLON.Vector4(0,0,1,1);

                    //create wheel and apply material
                    wheelFL = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter: 3, height: 1, tessellation: 24, faceColors:faceColors, faceUV:faceUV}, scene);
                    wheelFL.material = wheelMaterial;
                    
                    wheelFL.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.WORLD);
                    wheelFL.rotate(BABYLON.Axis.Y, Math.PI/2, BABYLON.Space.WORLD);
                    
                    wheelFL.position = new BABYLON.Vector3(0.4, 0.2, 0.45);
                    wheelFL.scaling = new BABYLON.Vector3(0.12, 0.22, 0.12);

                    // CRUCIAL LINE!!!
                    wheelFL.parent = car;

                    // other wheels
                    wheelFR = wheelFL.clone();
                    wheelFR.position.x = -0.4;

                    wheelRL = wheelFL.clone();
                    wheelRL.position = new BABYLON.Vector3(0.45, 0.2, -0.35);
                    wheelRL.scaling = new BABYLON.Vector3(0.15, 0.25, 0.15);
                    
                    wheelRR = wheelFL.clone();
                    wheelRR.position = new BABYLON.Vector3(-0.45, 0.2, -0.35);
                    wheelRR.scaling = new BABYLON.Vector3(0.15, 0.25, 0.15);

                    
                    // dispose does not work -> let's make the original wheels extremely small
                    result.meshes[3].scaling = new BABYLON.Vector3(0.00001, 0.00001, 0.00001);

                });
            else if(character_name == 'toad')
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_toad/", "scene.gltf", scene).then((result) => {
                    car = result.meshes[0];
                    car.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car.position.x = -5;
                    car.position.y = 0.7;
                    car.rotationQuaternion = null;
                    car.rotation.y = Math.PI;
                    camera.lockedTarget = car;

                    /*-----------------------Wheel------------------------------------------*/ 
	
                    // 'our' Wheel Material 
                    var wheelMaterial = new BABYLON.StandardMaterial("wheel_mat", scene);
                    var wheelTexture = new BABYLON.Texture("http://i.imgur.com/ZUWbT6L.png", scene);
                    wheelMaterial.diffuseTexture = wheelTexture;

                    //Set color for wheel tread as black
                    var faceColors=[];
                    faceColors[1] = new BABYLON.Color3(0,0,0);

                    //set texture for flat face of wheel 
                    var faceUV =[];
                    faceUV[0] = new BABYLON.Vector4(0,0,1,1);
                    faceUV[2] = new BABYLON.Vector4(0,0,1,1);

                    //create wheel and apply material
                    wheelFL = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter: 3, height: 1, tessellation: 24, faceColors:faceColors, faceUV:faceUV}, scene);
                    wheelFL.material = wheelMaterial;
                    
                    wheelFL.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.WORLD);
                    wheelFL.rotate(BABYLON.Axis.Y, Math.PI/2, BABYLON.Space.WORLD);
                    
                    wheelFL.position = new BABYLON.Vector3(0.65, 0.2, 1.1);
                    wheelFL.scaling = new BABYLON.Vector3(0.15, 0.25, 0.15);

                    // CRUCIAL LINE!!!
                    wheelFL.parent = car;

                    // other wheels
                    wheelFR = wheelFL.clone();
                    wheelFR.position.x = -0.55;

                    wheelRL = wheelFL.clone();
                    wheelRL.position = new BABYLON.Vector3(0.60, 0.2, 0);
                    
                    wheelRR = wheelFL.clone();
                    wheelRR.position = new BABYLON.Vector3(-0.525, 0.2, 0);
                    
                    // dispose does not work -> let's make the original wheels extremely small
                    //result.meshes[11].position.x = -3;
                    result.meshes[11].scaling = new BABYLON.Vector3(0.00001, 0.00001, 0.00001);
                
                });
            else if(character_name == 'bowser')
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_bowser/", "scene.gltf", scene).then((result) => {
                    car = result.meshes[0];
                    car.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car.position.x = -5;
                    car.position.y = 0.7;
                    car.rotationQuaternion = null;
                    car.rotation.y = Math.PI;
                    camera.lockedTarget = car;

                    /*-----------------------Wheel------------------------------------------*/ 
	
                    // 'our' Wheel Material 
                    var wheelMaterial = new BABYLON.StandardMaterial("wheel_mat", scene);
                    var wheelTexture = new BABYLON.Texture("http://i.imgur.com/ZUWbT6L.png", scene);
                    wheelMaterial.diffuseTexture = wheelTexture;

                    //Set color for wheel tread as black
                    var faceColors=[];
                    faceColors[1] = new BABYLON.Color3(0,0,0);

                    //set texture for flat face of wheel 
                    var faceUV =[];
                    faceUV[0] = new BABYLON.Vector4(0,0,1,1);
                    faceUV[2] = new BABYLON.Vector4(0,0,1,1);

                    //create wheel and apply material
                    wheelFL = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter: 3, height: 1, tessellation: 24, faceColors:faceColors, faceUV:faceUV}, scene);
                    wheelFL.material = wheelMaterial;
                    
                    wheelFL.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.WORLD);
                    wheelFL.rotate(BABYLON.Axis.Y, Math.PI/2, BABYLON.Space.WORLD);
                    
                    wheelFL.position = new BABYLON.Vector3(0.95, 0.3, 1.3);
                    wheelFL.scaling = new BABYLON.Vector3(0.29, 0.49, 0.29);

                    // CRUCIAL LINE!!!
                    wheelFL.parent = car;

                    // other wheels
                    wheelFR = wheelFL.clone();
                    wheelFR.position.x = -1.15;

                    wheelRL = wheelFL.clone();
                    wheelRL.position = new BABYLON.Vector3(0.95, 0.25, -0.25);
                    
                    wheelRR = wheelFL.clone();
                    wheelRR.position = new BABYLON.Vector3(-1.15, 0.25, -0.25);
                    
                    // dispose does not work -> let's make the original wheels extremely small
                    //result.meshes[2].position.x = -3;
                    result.meshes[2].scaling = new BABYLON.Vector3(0.00001, 0.00001, 0.00001);
                
                });
            else // donkey
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_dk/", "scene.gltf", scene).then((result) => {
                    car = result.meshes[0];
                    car.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car.position.x = -5;
                    car.position.y = 0.7;
                    car.rotationQuaternion = null;
                    car.rotation.y = Math.PI;
                    camera.lockedTarget = car;

                    /*-----------------------Wheel------------------------------------------*/ 
	
                    // 'our' Wheel Material 
                    var wheelMaterial = new BABYLON.StandardMaterial("wheel_mat", scene);
                    var wheelTexture = new BABYLON.Texture("http://i.imgur.com/ZUWbT6L.png", scene);
                    wheelMaterial.diffuseTexture = wheelTexture;

                    //Set color for wheel tread as black
                    var faceColors=[];
                    faceColors[1] = new BABYLON.Color3(0,0,0);

                    //set texture for flat face of wheel 
                    var faceUV =[];
                    faceUV[0] = new BABYLON.Vector4(0,0,1,1);
                    faceUV[2] = new BABYLON.Vector4(0,0,1,1);

                    //create wheel and apply material
                    wheelFL = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter: 3, height: 1, tessellation: 24, faceColors:faceColors, faceUV:faceUV}, scene);
                    wheelFL.material = wheelMaterial;
                    
                    wheelFL.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.WORLD);
                    wheelFL.rotate(BABYLON.Axis.Y, Math.PI/2, BABYLON.Space.WORLD);
                    
                    wheelFL.position = new BABYLON.Vector3(0.6, 0.1, 1.2);
                    wheelFL.scaling = new BABYLON.Vector3(0.12, 0.22, 0.12);

                    // CRUCIAL LINE!!!
                    wheelFL.parent = car;

                    // other wheels
                    wheelFR = wheelFL.clone();
                    wheelFR.position.x = -0.6;

                    wheelRL = wheelFL.clone();
                    wheelRL.position = new BABYLON.Vector3(0.6, 0.1, 0.5);
                    
                    wheelRR = wheelFL.clone();
                    wheelRR.position = new BABYLON.Vector3(-0.6, 0.1, 0.5);
                    
                    // dispose does not work -> let's make the original wheels extremely small
                    //result.meshes[2].position.x = -3;
                    result.meshes[2].scaling = new BABYLON.Vector3(0.00001, 0.00001, 0.00001);
                
                });
            
            // three cpu's cars
            points1.push(new BABYLON.Vector3(5, 0.7, 6.67));
            if(character_name!='toad'){
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_toad/", "scene.gltf", scene).then((result) => {
                    car1 = result.meshes[0];
                    car1.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car1.position.x = 5;
                    car1.position.y = 0.7;
                    car1.position.z = 6.67;
                    car1.rotationQuaternion = null;
                    car1.rotation.y = Math.PI;
                    car1.lap = 1;
                    car1.half_lap = false;
                });
            }
            else{
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_mario/", "scene.gltf", scene).then((result) => {
                    car1 = result.meshes[0];
                    car1.scaling = new BABYLON.Vector3(2.2, 2.2, -2.2);
                    car1.position.x = 5;
                    car1.position.y = 0.7;
                    car1.position.z = 6.67;
                    car1.rotationQuaternion = null;
                    car1.rotation.y = Math.PI;
                    car1.lap = 1;
                    car1.half_lap = false;
                });
            }

            points2.push(new BABYLON.Vector3(-5, 0.7, 13.37));
            if(character_name!='bowser'){
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_bowser/", "scene.gltf", scene).then((result) => {
                    car2 = result.meshes[0];
                    car2.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car2.position.x = -5;
                    car2.position.y = 0.7;
                    car2.position.z = 13.37;
                    car2.rotationQuaternion = null;
                    car2.rotation.y = Math.PI;
                    car2.lap = 1;
                    car2.half_lap = false;
                });
            }
            else{
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_mario/", "scene.gltf", scene).then((result) => {
                    car2 = result.meshes[0];
                    car2.scaling = new BABYLON.Vector3(2.2, 2.2, -2.2);
                    car2.position.x = -5;
                    car2.position.y = 0.7;
                    car2.position.z = 13.37;
                    car2.rotationQuaternion = null;
                    car2.rotation.y = Math.PI;
                    car2.lap = 1;
                    car2.half_lap = false;
                });
            }

            points3.push(new BABYLON.Vector3(5, 0.7, 20));
            if(character_name!='donkey'){ 
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_dk/", "scene.gltf", scene).then((result) => {
                    car3 = result.meshes[0];
                    car3.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car3.position.x = 5;
                    car3.position.y = 0.7;
                    car3.position.z = 20;
                    car3.rotationQuaternion = null;
                    car3.rotation.y = Math.PI;
                    car3.lap = 1;
                    car3.half_lap = false;
                });
            }
            else{
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_mario/", "scene.gltf", scene).then((result) => {
                    car3 = result.meshes[0];
                    car3.scaling = new BABYLON.Vector3(2.2, 2.2, -2.2);
                    car3.position.x = 5;
                    car3.position.y = 0.7;
                    car3.position.z = 20;
                    car3.rotationQuaternion = null;
                    car3.rotation.y = Math.PI;
                    car3.lap = 1;
                    car3.half_lap = false;
                });
            }

            // creating the item boxes and pushing points for the cpu's path
            createItemBoxLine(scene, [-7, 1, 130], true, false);
            createItemBoxLine(scene, [-7, 1, 300], true, false);

            points2.push(new BABYLON.Vector3(0, 1, 420));
            points2.push(new BABYLON.Vector3(65, 1, 460));
            points1.push(new BABYLON.Vector3(5, 1, 420));
            points1.push(new BABYLON.Vector3(65, 1, 455));
            points3.push(new BABYLON.Vector3(10, 1, 420));
            points3.push(new BABYLON.Vector3(65, 1, 450));

            createItemBoxLine(scene, [200, 1, 451], false, false);
            createItemBoxLine(scene, [400, 1, 451], false, false);

            points2.push(new BABYLON.Vector3(570, 1, 460));
            points2.push(new BABYLON.Vector3(625, 1, 400));
            points1.push(new BABYLON.Vector3(570, 1, 455));
            points1.push(new BABYLON.Vector3(620, 1, 400));
            points3.push(new BABYLON.Vector3(570, 1, 450));
            points3.push(new BABYLON.Vector3(615, 1, 400));

            createItemBoxLine(scene, [613.5, 1, 300], true, true);
            createItemBoxLine(scene, [613.5, 1, 130], true, true);
            points2.push(new BABYLON.Vector3(628.5, 1, 0));
            points1.push(new BABYLON.Vector3(624, 1, 0));
            points3.push(new BABYLON.Vector3(619.5, 1, 0));
            createItemBoxLine(scene, [613.5, 1, -130], true, true);
            createItemBoxLine(scene, [613.5, 1, -330], true, true);

            points2.push(new BABYLON.Vector3(625, 1, -460));
            points2.push(new BABYLON.Vector3(570, 1, -525));
            points1.push(new BABYLON.Vector3(620, 1, -460));
            points1.push(new BABYLON.Vector3(570, 1, -520));
            points3.push(new BABYLON.Vector3(615, 1, -460));
            points3.push(new BABYLON.Vector3(570, 1, -515));

            createItemBoxLine(scene, [400, 1, -527], false, true);
            createItemBoxLine(scene, [200, 1, -527], false, true);

            points2.push(new BABYLON.Vector3(70, 1, -527));
            points2.push(new BABYLON.Vector3(0, 1, -480));
            points1.push(new BABYLON.Vector3(70, 1, -522));
            points1.push(new BABYLON.Vector3(5, 1, -480));
            points3.push(new BABYLON.Vector3(70, 1, -517));
            points3.push(new BABYLON.Vector3(10, 1, -480));

            createItemBoxLine(scene, [-7, 1, -330], true, false);
            createItemBoxLine(scene, [-7, 1, -130], true, false);

            points1.push(points1[0]); // push to close path
            points2.push(points2[0]); // push to close path
            points3.push(points3[0]); // push to close path

            return scene;
        };

        const scene = createScene(); // Call the createScene function

        // initial button
        var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        var button = BABYLON.GUI.Button.CreateImageButton("but", "Welcome to Luigi Circuit!             \nClick to start the race.             ", "");
        button.height = "100px";
        button.width = "350px";
        button.background = 'green';
        button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        advancedTexture.addControl(button);
        button.pointerDownAnimation = () => {
            advancedTexture.dispose();
            startSounds();
        };

        function startSounds(){
            // adding sounds
            const soundStart = new BABYLON.Sound("soundStart", "sounds/mk64_racestart.wav", scene, function(){
                    soundStart.play();
            });

            // once the start sound is over we proceed with the countdown
            soundStart.onended = function(){
                // countdown for the race to start
                var countTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                var i = 3; // seconds
                var textBlock = new BABYLON.GUI.TextBlock("text", new String(i));   
                textBlock.color = "orange";
                textBlock.fontSize = 150;
                textBlock.fontFamily = "impact";
                
                countTexture.addControl(textBlock);
                var handle = window.setInterval(() => {
                    i--;
                    textBlock.text = new String(i)

                    if (i === 0) {
                        textBlock.text = "GO!"
                    }

                    if (i == -1){
                        window.clearInterval(handle);

                        textBlock.dispose();
                        countTexture.dispose();
                    }
                }, 890);
                
                const countSound = new BABYLON.Sound("countSound", "sounds/mk64_countdown.wav", scene, function(){
                    countSound.play();
                });
                
                countSound.onended = function(){
                    startRace(car);
                }
            };
        }

        // this fn creates a set of four aligned (along x- or z-axis) item boxes
        function createItemBoxLine(scene, starting_pos, alignedX, opposed){
            if(alignedX&&!opposed){
                points2.push(new BABYLON.Vector3(starting_pos[0]+4.5, starting_pos[1], starting_pos[2]));
                points1.push(new BABYLON.Vector3(starting_pos[0]+9, starting_pos[1], starting_pos[2]));
                points3.push(new BABYLON.Vector3(starting_pos[0]+13.5, starting_pos[1], starting_pos[2]));
            }
            else if(alignedX&&opposed){
                points3.push(new BABYLON.Vector3(starting_pos[0]+4.5, starting_pos[1], starting_pos[2]));
                points1.push(new BABYLON.Vector3(starting_pos[0]+9, starting_pos[1], starting_pos[2]));
                points2.push(new BABYLON.Vector3(starting_pos[0]+13.5, starting_pos[1], starting_pos[2]));
            }
            else if(!alignedX&&opposed){
                points1.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+9));
                points3.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+13.5));
                points2.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+4.5));
            }
            else{
                points1.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+9));
                points2.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+13.5));
                points3.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+4.5));
            }
            BABYLON.SceneLoader.ImportMeshAsync("", "models/item_box/", "scene.gltf", scene).then((result) => {
                itemBox = result.meshes[0];
                itemBox.scaling = new BABYLON.Vector3(0.05, 0.05, 0.05);
                itemBox.position.z = starting_pos[2];
                itemBox.position.y = starting_pos[1];
                itemBox.position.x = starting_pos[0];
                itemBox.rotationQuaternion = null;  

                itemBoxPos.push([itemBox.position.x, itemBox.position.y, itemBox.position.z]);
                itemBoxes.push(itemBox);

                otherBox1 = itemBox.clone();
                otherBox2 = itemBox.clone();
                otherBox3 = itemBox.clone();

                if (alignedX){
                    otherBox1.position.x = itemBox.position.x + 4.5;
                    otherBox2.position.x = itemBox.position.x + 9;
                    otherBox3.position.x = itemBox.position.x + 13.5;
                }
                else{
                    otherBox1.position.z = itemBox.position.z + 4.5;
                    otherBox2.position.z = itemBox.position.z + 9;
                    otherBox3.position.z = itemBox.position.z + 13.5;
                }    
                itemBoxPos.push([otherBox1.position.x, otherBox1.position.y, otherBox1.position.z]);
                itemBoxPos.push([otherBox2.position.x, otherBox2.position.y, otherBox2.position.z]);
                itemBoxPos.push([otherBox3.position.x, otherBox3.position.y, otherBox3.position.z]);

                itemBoxes.push(otherBox1);
                itemBoxes.push(otherBox2);
                itemBoxes.push(otherBox3);

                // for the path that the other cars have to follow we can use the position
                // of the instantiated item boxes as reference points: the cars will pass though
                // one on the four aligned box in every set above
            });
        }

        // we need to distinguish a positive and a negative item
        var positiveItem = false;

        // before use/throw the object we have it 'attached' to the car
        function createItem(name){
            var previous_item = item;
            if (name == 'banana'){
                if (previous_item){
                    posx = previous_item.position.x;
                    posy = previous_item.position.y;
                    posz = previous_item.position.z;
                    if (positiveItem){
                        goodItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            goodItemPos.push([posx, posy, posz])
                            
                        }, 500);

                    }
                    else {        
                        lethalItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            lethalItemPos.push([posx, posy, posz])
                            
                        }, 500);
                    }
                }
                item_name = 'banana';
                const soundItems = new BABYLON.Sound("soundItems", "sounds/items.mp3", scene, function(){
                    soundItems.play();
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "models/banana/", "scene.gltf", scene).then((result) => {
                    if(previous_item){
                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mk64_banana.wav", scene, function(){
                            soundDrop.play();
                        });
                    }
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.002, 0.002, 0.002);
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                    item.position.y = -4.5;
                    positiveItem = false;
                    soundItems.onended = function(){
                        if(item)
                            item.position.y = 4.5;
                    }
                });
            }
            else if (name == 'red_shell'){
                if (previous_item){
                    posx = previous_item.position.x;
                    posy = previous_item.position.y;
                    posz = previous_item.position.z;                  

                    if (positiveItem){
                        goodItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            goodItemPos.push([posx, posy, posz])
                            
                        }, 500);

                    }
                    else {        
                        lethalItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            lethalItemPos.push([posx, posy, posz])
                            
                        }, 500);
                    }
                }
                item_name = 'red_shell';
                const soundItems = new BABYLON.Sound("soundItems", "sounds/items.mp3", scene, function(){
                    soundItems.play();
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "models/red_shell/", "scene.gltf", scene).then((result) => {
                    if(previous_item){
                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mouseover.mp3", scene, function(){
                            soundDrop.play();
                        });
                    }
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.15, 0.15, 0.15);
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                    item.position.y = -4.5;
                    positiveItem = false;
                    soundItems.onended = function(){
                        if(item)
                            item.position.y = 4.5;
                    }
                });
            }
            else if (name == 'mushroom'){
                if (previous_item){
                    posx = previous_item.position.x;
                    posy = previous_item.position.y;
                    posz = previous_item.position.z;                  

                    if (positiveItem){
                        goodItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            goodItemPos.push([posx, posy, posz])
                            
                        }, 500);

                    }
                    else {        
                        lethalItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            lethalItemPos.push([posx, posy, posz])
                            
                        }, 500);
                    } 
                }
                item_name = 'mushroom';
                const soundItems = new BABYLON.Sound("soundItems", "sounds/items.mp3", scene, function(){
                    soundItems.play();
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "models/mushroom/", "scene.gltf", scene).then((result) => {
                    if(previous_item){
                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mouseover.mp3", scene, function(){
                            soundDrop.play();
                        });
                    }
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
                    item.position.y = -4.5;
                    item.rotationQuaternion = null;
                    item.rotation.y = Math.PI / 2;
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                    positiveItem = true;
                    soundItems.onended = function(){
                        if(item)
                            item.position.y = 4.5;
                    }
                });
            }
            else if (name == 'green_shell'){
                if (previous_item){
                    posx = previous_item.position.x;
                    posy = previous_item.position.y;
                    posz = previous_item.position.z;                  

                    if (positiveItem){
                        goodItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            goodItemPos.push([posx, posy, posz])
                            
                        }, 500);

                    }
                    else {        
                        lethalItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            lethalItemPos.push([posx, posy, posz])
                            
                        }, 500);
                    } 
                }
                item_name = 'green_shell';
                const soundItems = new BABYLON.Sound("soundItems", "sounds/items.mp3", scene, function(){
                    soundItems.play();
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "models/green_shell/", "scene.gltf", scene).then((result) => {
                    if(previous_item){
                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mouseover.mp3", scene, function(){
                            soundDrop.play();
                        });
                    }
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.005, 0.005, 0.005);
                    item.position.y = -4.5;
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                    item.rotationQuaternion = null;
                    item.rotation.y = Math.PI / 2;
                    positiveItem = false;
                    soundItems.onended = function(){
                        if(item)
                            item.position.y = 4;
                    }
                });
            }
            else {
                console.log("Unsopperted item to be created! Please, debug.")
            }
        }

        // if the car is out of the street or in the sand I will have more friction
        function setImpedance(car) {
            impedance = 0.0;
            
            if ((car.position.z > -534 && car.position.z < 471 && car.position.x > -13 && car.position.x < 634)&&
                 !(car.position.z > -507 && car.position.z < 444 && car.position.x > 13.5 && car.position.x < 607))
                impedance = 0.0;
            else
                impedance = 0.3;

            return impedance;
        }

        var lap = 1;
        // arrays to store the cars in front of us or behind us
        var carsBehind = [], carsFront = [];

        function startRace(car) {
            var startTime = new Date().getTime();
            angle = car.rotation.y - Math.PI;

            // array to store all the cars involved in the race
            // REMEMBER: index = 0 -> our car, index > 0 -> 'enemies'
            var carsAll = [car, car1, car2, car3];

            // at the beginning we are 4th, therefore:
            carsFront = [car1, car2, car3];
            // moreover, we will always use the carsFront array to determine our position during the race, in fact:
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            // user interface
            let x1 = new BABYLON.GUI.TextBlock('TextBlock', ''); 
            x1.fontSize = 50;
            x1.fontFamily = "impact";
            x1.color = "yellow";
            var rect1 = new BABYLON.GUI.Rectangle();
            rect1.width = 0.23;
            rect1.height = 0.21;
            rect1.paddingTop = '3%';
            rect1.paddingRight = '3%';
            rect1.horizontalAlignment = 1;
            rect1.verticalAlignment = 0;
            rect1.cornerRadius = 10;
            rect1.color = "black";
            rect1.thickness = 4;
            rect1.background = "darkgreen";
            advancedTexture.addControl(rect1);
            rect1.addControl(x1);

            let x2 = new BABYLON.GUI.TextBlock('TextBlock', ''); 
            x2.fontSize = 50;
            x2.fontFamily = "impact";
            x2.color = "yellow";
            var rect2 = new BABYLON.GUI.Rectangle();
            rect2.width = 0.18;
            rect2.height = 0.13;
            rect2.paddingBottom = '3%';
            rect2.paddingLeft = '3%';
            rect2.horizontalAlignment = 0;
            rect2.verticalAlignment = 1;
            rect2.cornerRadius = 10;
            rect2.color = "black";
            rect2.thickness = 4;
            rect2.background = "darkgreen";
            advancedTexture.addControl(rect2);
            rect2.addControl(x2);

            x1.text = 'Lap ' + String(lap) + '/3' + '\n Time: ' + String(0);
            x2.text = 'Position: ' + String(carsFront.length + 1);

            // these variables handle the collisions with the (horizontal/vertical) walls
            var wall_horiz1 = false, wall_horiz2 = false;
            var wall_vert1 = false, wall_vert2 = false;
            var wall_horiz_op1 = false, wall_horiz_op2 = false;
            var wall_vert_op1 = false, wall_vert_op2 = false;

            // let's start the soundtrack of the Luigi's Circuit
            const luigiSound = new BABYLON.Sound("luigiSound", "sounds/mk64_luigicircuit.mp3", scene, null, {
                loop: true,
                autoplay: true,
                volume: 0.2
            });

            // here we handle the animation of the other three cars in the race
            const animCarX1 = new BABYLON.Animation("canAnimationx1", "position.x", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            const animCarZ1 = new BABYLON.Animation("canAnimationz1", "position.z", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            
            const animCarX2 = new BABYLON.Animation("canAnimationx2", "position.x", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            const animCarZ2 = new BABYLON.Animation("canAnimationz2", "position.z", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            const animCarX3 = new BABYLON.Animation("canAnimationx3", "position.x", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            const animCarZ3 = new BABYLON.Animation("canAnimationz3", "position.z", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            const rotCar = new BABYLON.Animation("rotAnimationz1", "rotation.y", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            const carKeysX1 = [];
            const carKeysZ1 = [];
            
            const carKeysX2 = [];
            const carKeysZ2 = [];

            const carKeysX3 = [];
            const carKeysZ3 = [];

            const rotKeys = [];

            frame = 0;
            for (j=0; j<points1.length; j++){
                carKeysX1.push({
                    frame: frame,
                    value: points1[j].x
                });
                carKeysZ1.push({
                    frame: frame,
                    value: points1[j].z
                });

                carKeysX2.push({
                    frame: frame,
                    value: points2[j].x
                });
                carKeysZ2.push({
                    frame: frame,
                    value: points2[j].z
                });

                carKeysX3.push({
                    frame: frame,
                    value: points3[j].x
                });
                carKeysZ3.push({
                    frame: frame,
                    value: points3[j].z
                });

                // rotation animation
                if(j == 0){
                    rotKeys.push({
                        frame: frame,
                        value:  Math.PI
                    });
                }
                else if(j == 4){
                    rotKeys.push({
                        frame: frame,
                        value:  Math.PI*3 / 2
                    });
                }
                else if(j == 8){
                    rotKeys.push({
                        frame: frame,
                        value:  Math.PI*2
                    });
                }
                else if(j == 15){
                    rotKeys.push({
                        frame: frame,
                        value: Math.PI*5/2
                    });
                }
                else if(j == 19){
                    rotKeys.push({
                        frame: frame,
                        value: Math.PI*3
                    });
                }
                else{
                    rotKeys.push({
                        frame: frame,
                        value:  rotKeys[rotKeys.length - 1].value
                    });
                }

                frame += 150;
            }
            animCarX1.setKeys(carKeysX1);
            animCarZ1.setKeys(carKeysZ1);
            rotCar.setKeys(rotKeys);
            
            animCarX2.setKeys(carKeysX2);
            animCarZ2.setKeys(carKeysZ2);

            animCarX3.setKeys(carKeysX3);
            animCarZ3.setKeys(carKeysZ3);

            // we store the animations in some variables to use them if the computer-controlled cars hit a lethal items
            var carAnimation1 = scene.beginDirectAnimation(car1, [animCarX1, animCarZ1, rotCar], 0, frame, true);
            carAnimation1.speedRatio *= 0.97;
            var carAnimation2 = scene.beginDirectAnimation(car2, [animCarX2, animCarZ2, rotCar], 0, frame, true);
            carAnimation2.speedRatio *= 1.03;
            var carAnimation3 = scene.beginDirectAnimation(car3, [animCarX3, animCarZ3, rotCar], 0, frame, true);
            
            // decomment these lines if you want to test the paths of the computer-controlled cars
            // Creation of a lines mesh
            /*
            var lines1 = BABYLON.MeshBuilder.CreateLines("lines", {points: points1}, scene);
            var lines2 = BABYLON.MeshBuilder.CreateLines("lines", {points: points2}, scene);
            lines2.color = new BABYLON.Color3(1, 0, 0);
            var lines3 = BABYLON.MeshBuilder.CreateLines("lines", {points: points3}, scene);
            lines3.color = new BABYLON.Color3(0, 1, 0);
            */

            var base_speed = 0.5;
            var impedance = 0.0;
            // velocity increment when shell is thrown ...
            var throwed = 0;
            // ... but also when a mushroom is used
            var sprint = 0;
            var acceleration = 0;

            // ensures that the user actually follows the track
            var half_lap = false;

            // timer
            var timer = setInterval(function(){
                if(lap <= 3){
                    x1.text = 'Lap ' + String(lap) + '/3' + '\n Time: ' + String(raceTime);
                }
            }, 10);

            // end game routine
            function endGame(){
                clearInterval(timer);
                carAnimation1.stop();
                carAnimation2.stop();
                carAnimation3.stop();
                game_ended = true;
                setTimeout(function(){
                    var finishTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                    var textBlock = new BABYLON.GUI.TextBlock("text", new String(i));   
                    textBlock.color = "orange";
                    textBlock.fontSize = 150;
                    textBlock.fontFamily = "impact";
                    finishTexture.addControl(textBlock);
                    textBlock.text = "FINISH!";
                    var handle = window.setInterval(() => {
                        window.clearInterval(handle);
                        textBlock.dispose();
                        finishTexture.dispose();
                    }, 2000);

                    final_position = carsFront.length+1;
                    
                    if(final_position == 1)
                        score += 15;
                    else if(final_position == 2)
                        score += 10;
                    else if(final_position == 3)
                        score += 5;
                    else
                        score += 0;

                    setTimeout(function(){
                        var positionTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                        var textBlock = new BABYLON.GUI.TextBlock("text", '');   
                        textBlock.color = "orange";
                        textBlock.fontSize = 150;
                        textBlock.fontFamily = "impact";
                        positionTexture.addControl(textBlock);
                        textBlock.text = "YOU ARRIVED " + String(final_position) + "/4";
                        var handle = window.setInterval(() => {
                            window.clearInterval(handle);
                            textBlock.dispose();
                            positionTexture.dispose();
                        }, 3000);
                    }, 2100);
                    
                    setTimeout(function(){
                        // if grandPrix, next race
                        if(parent.document.URL.indexOf('&') > 1){
                            var scoreTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                            var textBlock = new BABYLON.GUI.TextBlock("text", '');   
                            textBlock.color = "orange";
                            textBlock.fontSize = 150;
                            textBlock.fontFamily = "impact";
                            scoreTexture.addControl(textBlock);
                            textBlock.text = "YOUR CURRENT SCORE IS:\n" + String(score) + "/45\nPress C to continue!";
                            var handle = window.setInterval(() => {
                                window.clearInterval(handle);
                                textBlock.dispose();
                                scoreTexture.dispose();
                            }, 10000);
                        }
                        // else back to menu
                        else{
                            var scoreTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                            var textBlock = new BABYLON.GUI.TextBlock("text", '');   
                            textBlock.color = "orange";
                            textBlock.fontSize = 150;
                            textBlock.fontFamily = "impact";
                            scoreTexture.addControl(textBlock);
                            textBlock.text = "Press C to continue!";
                            var handle = window.setInterval(() => {
                                window.clearInterval(handle);
                                textBlock.dispose();
                                scoreTexture.dispose();
                            }, 10000);
                        }
                    }, 5500);
                }, 1000);
            }

            scene.registerBeforeRender(function () {
                fps_interface.innerHTML = engine.getFps().toFixed() + " fps";
                
                var currentTime = new Date().getTime();
                raceTime = ((currentTime - startTime)/1000).toFixed(3);
                impedance = setImpedance(car);
                
                // collision car-itembox loop
                for (i=0; i<itemBoxPos.length; i++){
                    if(car.position.x < itemBoxPos[i][0]+1.5 && car.position.x > itemBoxPos[i][0]-1.5 && car.position.z < itemBoxPos[i][2]+1.5 && car.position.z > itemBoxPos[i][2]-1.5){
                        if(item)
                            item.position.y = 0.95;
                        // we have four items randomly chosen
                        throwed = 0;
			
			// 25% for each item
			r = Math.random();
			    
                        if(r < 0.25)
                            createItem('red_shell');
                        
                        else if(r < 0.5)
                            createItem('banana');
                        
                        else if(r < 0.75)
                            createItem('mushroom');
                        
                        else
                            createItem('green_shell');
                        
                        // removing the 'hitten' item box from the arrays of item boxes
                        itemBoxes[i].dispose();
                        itemBoxes.splice(i, 1);
                        itemBoxPos.splice(i, 1);
                        break;
                    }
                }

                // collision with lethal items (moving shells included)
                // we iterate over ALL the cars that can be hitten by one lethal item
                for (var k=0; k<carsAll.length; k++){
                    // collision car-lethals loop: the car passes over a lethal item, it will do a spin (testacoda)
                    for (i=0; i<lethalItemPos.length; i++){
                        if((carsAll[k].position.x < lethalItemPos[i][0]+1.5 && carsAll[k].position.x > lethalItemPos[i][0]-1.5 && carsAll[k].position.z < lethalItemPos[i][2]+1.5 && carsAll[k].position.z > lethalItemPos[i][2]-1.5)
                            || (k>0 && item && throwed > 0 && carsAll[k].position.x < item.position.x+4 && carsAll[k].position.x > item.position.x-4 && carsAll[k].position.z < item.position.z+4 && carsAll[k].position.z > item.position.z-4)){
                            
                            if(k>0 && item && throwed > 0 && carsAll[k].position.x < item.position.x+4 && carsAll[k].position.x > item.position.x-4 && carsAll[k].position.z < item.position.z+4 && carsAll[k].position.z > item.position.z-4){
                                item.dispose();
                                item = null;
                            }

                            // our car
                            if (k == 0){
                                soundHit = new BABYLON.Sound("soundStart", "sounds/mammamia.mp3", scene, function(){
                                    luigiSound.pause();
                                    soundHit.play();
                                });
                                soundHit.onended = function(){
                                    luigiSound.play();
                                }
                            }
                            /* the spin is realized with a combination of three animations:
                            * - carRotation: 'actual' spin
                            * - carStopx: necessary to do not move the car along the x-axis
                            * - carStopz: necessary to do not move the car along the z-axis
                            * without these last two, the car will proceed in its motion
                            */
                            // every animation is composed by key frames
                            var carRotation = new BABYLON.Animation("carRotation", "rotation.y", 10, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                            const keyFramesRot = []; 
                            
                            var carStopx = new BABYLON.Animation("carStopx", "position.x", 10, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                            var carStopz = new BABYLON.Animation("carStopx", "position.z", 10, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                            const keyFramesPosx = [];
                            const keyFramesPosz = [];

                            const initial_rot = carsAll[k].rotation.y;
                            const initial_posx = carsAll[k].position.x;
                            const initial_posz = carsAll[k].position.z;
                            
                            var spin = Math.PI;
                            for (j=0; j<5; j++){
                                keyFramesRot.push({
                                    frame: 5*j,
                                    value: initial_rot + spin
                                });
                                spin += Math.PI;

                                keyFramesPosx.push({
                                    frame: 5*j,
                                    value: initial_posx
                                });
                                keyFramesPosz.push({
                                    frame: 5*j,
                                    value: initial_posz
                                });
                            }
                            keyFramesRot.push({
                                frame: 30,
                                value: initial_rot
                            })
                        
                            carRotation.setKeys(keyFramesRot);
                            carStopx.setKeys(keyFramesPosx);
                            carStopz.setKeys(keyFramesPosz);

                            // for our car we only need to start the animation of the spin ...
                            if (k == 0) scene.beginDirectAnimation(car, [carRotation, carStopx, carStopz], 0, 60, false);
                            // ... while for all the others, we need to pause their motion animations, start the spin and then
                            // we resume their motion AFTER (!!!) the end of the spin -> async + await
                            else if (k == 1){
                                carAnimation1.pause()
                                setTimeout(async () => {
                                    var anim = scene.beginDirectAnimation(car1, [carRotation, carStopx, carStopz], 0, 60, false);
                                    await anim.waitAsync();
                                    carAnimation1.restart();
                                });
                            }
                            else if (k == 2){
                                carAnimation2.pause()
                                setTimeout(async () => {
                                    var anim = scene.beginDirectAnimation(car2, [carRotation, carStopx, carStopz], 0, 60, false);
                                    await anim.waitAsync();
                                    carAnimation2.restart();
                                });
                            }
                            else {
                                carAnimation3.pause()
                                setTimeout(async () => {
                                    var anim = scene.beginDirectAnimation(car3, [carRotation, carStopx, carStopz], 0, 60, false);
                                    await anim.waitAsync();
                                    carAnimation3.restart();
                                });
                            }

                            lethalItems[i].dispose();
                            lethalItems.splice(i, 1);
                            lethalItemPos.splice(i, 1);

                            // only our car has the item
                            if (k == 0){
                                setTimeout(function(){
                                    if(item){
                                            item.position.z = car.position.z;
                                            item.position.x = car.position.x;
                                    }
                                }, 3000);
                            }
                            break;
                        }
                    }
                }

                // collision with good items (aka mushrooms)
                // we iterate over ALL the cars that can pass over one mushroom
                // for simplicity, only our car will do the sprint given by the item
                for (var k=0; k<carsAll.length; k++){
                    // collision car-goods: the car passes over a positive item (aka a mushroom), it will accelerate
                    for (i=0; i<goodItemPos.length; i++){
                        if(carsAll[k].position.x < goodItemPos[i][0]+0.8 && carsAll[k].position.x > goodItemPos[i][0]-0.8 && carsAll[k].position.z < goodItemPos[i][2]+0.8 && carsAll[k].position.z > goodItemPos[i][2]-0.8){
                            // our car
                            if (k == 0) {
                                // play the mushroom sound
                                const soundMush = new BABYLON.Sound("soundMush", "sounds/mushroom.mp3", scene, function(){
                                    soundMush.play();
                                });
                                var repeat = true;
                                soundMush.onended = function(){
                                    if (repeat){
                                        soundMush.play();
                                        repeat = false;
                                    }
                                }
                                
                                sprint = 1;
                            }

                            goodItems[i].dispose();
                            goodItems.splice(i, 1);
                            goodItemPos.splice(i, 1);

                            break;
                        }
                    }
                }

                // collision car-endWorld: (car_x-center_x)^2 + (car_z-center_z)^2 > radius^2
                if(Math.pow(car.position.x-325, 2)+ Math.pow(car.position.z+60, 2) > 422500){
                    var endWorldTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                        var textBlock = new BABYLON.GUI.TextBlock("text", '');   
                        textBlock.color = "orange";
                        textBlock.fontSize = 100;
                        textBlock.fontFamily = "impact";
                        endWorldTexture.addControl(textBlock);
                        textBlock.text = "You are not supposed to be here..\n Back to the track!";
                        var handle = window.setInterval(() => {
                            window.clearInterval(handle);
                            textBlock.dispose();
                            endWorldTexture.dispose();
                        }, 3000);
                    if(half_lap){
                        car.position.x = 620;
                        car.position.z = 35;
                        car.rotation.y = 0;
                    }
                    else{
                        car.position.x = -5;
                        car.position.z = 0;
                        car.rotation.y = Math.PI;
                    }
                }

                // collision car-walls: change rotation
                // check over the vertical walls
                if (car.position.x < -13 && car.position.z > -440 && car.position.z < 360) wall_vert1 = true;                     
                if (car.position.x > 12 && car.position.x < 20 && car.position.z > -440 && car.position.z < 360) wall_vert_op1 = true;                     
                if (car.position.x > 633 && car.position.z > -440 && car.position.z < 360) wall_vert2 = true;                     
                if (car.position.x < 605 && car.position.x > 600 && car.position.z > -440 && car.position.z < 360) wall_vert_op2 = true;                     
                
                // correcting directions for vertical walls
                if (wall_vert1 || wall_vert_op2){
                    car.rotation.y -= 2 * angle;
                    car.position.x += 2;
                    if (item && throwed == 0) item.position.x = car.position.x;
                    wall_vert1 = false;
                    wall_vert_op2 = false;
                }
                if (wall_vert_op1 || wall_vert2){
                    car.rotation.y -= 2 * angle;
                    car.position.x -= 2;
                    if (item && throwed == 0) item.position.x = car.position.x;
                    wall_vert_op1 = false;
                    wall_vert2 = false;
                }

                // check over the horizontal walls
                if (car.position.x > 115 && car.position.x < 510 && car.position.z < 444 && car.position.z > 440) wall_horiz1 = true;
                if (car.position.x > 115 && car.position.x < 510 && car.position.z < -501 && car.position.z > -505) wall_horiz2 = true;

                // correcting directions for horizontal walls
                if (wall_horiz1){
                    car.rotation.y -= angle / 4;
                    car.position.z += 2;
                    if (item && throwed == 0) item.position.z = car.position.z;
                    wall_horiz1 = false; 
                }
                if (wall_horiz2){
                    car.rotation.y += angle / 4;
                    car.position.z -= 2;
                    if (item && throwed == 0) item.position.z = car.position.z;
                    wall_horiz2 = false; 
                }

                // control overtakings:
                // 1) we actively overtake
                for (var k=0; k<carsFront.length; k++){
                    if(carsFront[k].lap <= lap && carsFront[k].half_lap == half_lap){
                        // first straight line + beginning of the first curve: we monitor the z values
                        if (car.position.x > -16 && car.position.x < 40) {
                            if (car.position.z > carsFront[k].position.z && carsFront[k].position.x > -16 && carsFront[k].position.x < 40){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        // second straight line + beginning of the second curve: we monitor the x values
                        else if (car.position.z > 442 && car.position.z < 500) {
                            if (car.position.x > carsFront[k].position.x && carsFront[k].position.z > 442 && carsFront[k].position.z < 500){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        // thrid straight line + beginning of the thrid curve: we monitor the z values
                        else if (car.position.x > 579 && car.position.x < 635) {
                            if (car.position.z < carsFront[k].position.z && carsFront[k].position.x > 579 && carsFront[k].position.x < 635){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        // forth straight line + beginning of the forth curve: we monitor the x values
                        else if (car.position.z > -580 && car.position.z < -503) {
                            if (car.position.x < carsFront[k].position.x && carsFront[k].position.z > -580 && carsFront[k].position.z < -503){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                    }
                }
                // 2) we are passively overtaken
                for (var k=0; k<carsBehind.length; k++){
                    if(carsBehind[k].lap == lap && carsBehind[k].half_lap == half_lap){
                        // first straight line + beginning of the first curve: we monitor the z values
                        if (car.position.x > -16 && car.position.x < 40) {
                            if (car.position.z < carsBehind[k].position.z && carsBehind[k].position.x > -16 && carsBehind[k].position.x < 40){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        // second straight line + beginning of the second curve: we monitor the x values
                        else if (car.position.z > 442 && car.position.z < 500) {
                            if (car.position.x < carsBehind[k].position.x && carsBehind[k].position.z > 442 && carsBehind[k].position.z < 500){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);                        }
                        }
                        // thrid straight line + beginning of the thrid curve: we monitor the z values
                        else if (car.position.x > 579 && car.position.x < 635) {
                            if (car.position.z > carsBehind[k].position.z && carsBehind[k].position.x > 579 && carsBehind[k].position.x < 635){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);                        }
                        }
                        // forth straight line + beginning of the forth curve: we monitor the x values
                        else if (car.position.z > -580 && car.position.z < -503) {
                            if (car.position.x > carsBehind[k].position.x && carsBehind[k].position.z > -580 && carsBehind[k].position.z < -503){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);                        }
                        }
                    }
                }

                // game loop
                if(lap <= 3){
                    // car's movement update
                    car.position.z += (base_speed + acceleration + sprint - impedance) * Math.cos(angle);
                    car.position.x += (base_speed + acceleration + sprint - impedance) * Math.sin(angle);

                    // wheels' animation
                    wheelFL.rotate(BABYLON.Axis.Y, (base_speed + acceleration + sprint - impedance)/3, BABYLON.Space.LOCAL);
                    wheelFR.rotate(BABYLON.Axis.Y, (base_speed + acceleration + sprint - impedance)/3, BABYLON.Space.LOCAL);
                    wheelRL.rotate(BABYLON.Axis.Y, (base_speed + acceleration + sprint - impedance)/3, BABYLON.Space.LOCAL);
                    wheelRR.rotate(BABYLON.Axis.Y, (base_speed + acceleration + sprint - impedance)/3, BABYLON.Space.LOCAL);

                    // item's movement update
                    if(item){
                        if(throwed == 0){
                            item.position.z += (base_speed + acceleration + throwed + sprint - impedance) * Math.cos(angle);
                            item.position.x += (base_speed + acceleration + throwed + sprint - impedance) * Math.sin(angle);
                            // saved to throw shell in the right direction
                            last_angle = angle;
                        }
                        else{
                            item.position.z += (base_speed + acceleration + throwed + sprint - impedance) * Math.cos(last_angle);
                            item.position.x += (base_speed + acceleration + throwed + sprint - impedance) * Math.sin(last_angle);
                        }
                                      
                    }
                    // trick to gradually reduce the sprint of a mushroom
                    if (sprint > 0) sprint -= 0.002;

                    angle = car.rotation.y - Math.PI;
                    
                    // You must arrive to half lap to increase lap when you arrive to the finish line
                    if (car.position.z <37 && car.position.z >33 && car.position.x <640 && car.position.x >600){
                        half_lap = true;
                        car.rotation.y = Math.PI*2;
                    }
                    // lap's increment and update
                    if(half_lap && car.position.x <14 && car.position.x >-14 && car.position.z <33 && car.position.z >30){
                        if(lap <=2){
                            var lapTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                            var textBlock = new BABYLON.GUI.TextBlock("text", new String(i));   
                            textBlock.color = "orange";
                            textBlock.fontSize = 150;
                            textBlock.fontFamily = "impact";
                            lapTexture.addControl(textBlock);
                            textBlock.text = "LAP " + String(lap) + " FINISHED!";
                            var handle = window.setInterval(() => {
                                window.clearInterval(handle);
                                textBlock.dispose();
                                lapTexture.dispose();
                            }, 3000);

                            if(lap <= 1){
                                soundLap = new BABYLON.Sound("soundStart", "sounds/lap.mp3", scene, function(){
                                    luigiSound.pause();
                                    soundLap.play();
                                });
                                soundLap.onended = function(){
                                    luigiSound.play();
                                }
                            }
                            else{
                                soundFinalLap = new BABYLON.Sound("soundStart", "sounds/final_lap.mp3", scene, function(){
                                    luigiSound.pause();
                                    soundFinalLap.play();
                                });
                                soundFinalLap.onended = function(){
                                    luigiSound.play();
                                }
                            }
                            x1.text = 'Lap ' + String(lap) + '/3' + '\n Time: ' + String(raceTime);
                        }
                        lap += 1;
                        car.rotation.y = Math.PI;
                        half_lap = false;
                    }
                    var speed = base_speed + acceleration + sprint - impedance;

                    // cpu lap
                    if (car1.position.z < 37 && car1.position.z > 33 && car1.position.x > 600 && car1.position.x < 640)
                        car1.half_lap = true;
                    if (car2.position.z < 37 && car2.position.z > 33 && car2.position.x > 600 && car2.position.x < 640)
                        car2.half_lap = true;
                    if (car3.position.z < 37 && car3.position.z > 33 && car3.position.x > 600 && car3.position.x < 640)
                        car3.half_lap = true;

                    if(car1.half_lap && car1.position.z < 33 && car1.position.z > 30 && car1.position.x < 14 && car1.position.x > -14){
                        car1.half_lap = false;
                        car1.lap += 1;
                    }
                    if(car2.half_lap && car2.position.z < 33 && car2.position.z > 30 && car2.position.x < 14 && car2.position.x > -14){
                        car2.half_lap = false;
                        car2.lap += 1;
                    }
                    if(car3.half_lap && car3.position.z < 33 && car3.position.z > 30 && car3.position.x < 14 && car3.position.x > -14){
                        car3.half_lap = false;
                        car3.lap += 1;
                    }
                }
                // end game
                else{
                    if (speed > 0){
                        speed -= 0.002;
                        car.position.z += speed * Math.cos(angle);
                        car.position.x += speed * Math.sin(angle);
                    }

                    if(!update_done){
                        update_done = true;
                        const soundEnd = new BABYLON.Sound("soundEnd", "sounds/results.mp3", scene, function(){
                        luigiSound.stop();
                        soundEnd.play();
                        });
                        endGame();
                    }
                }
            });

            // controls
            scene.onKeyboardObservable.add((kbInfo) => {
                switch (kbInfo.type) {
                    case BABYLON.KeyboardEventTypes.KEYDOWN:
                        switch (kbInfo.event.key) {
                            case "a":
                            case "A":
                                car.rotation.y -= Math.PI / 18;
                                acceleration = 0;
                                break;

                            case "d":
                            case "D":
                                car.rotation.y += Math.PI / 18;
                                acceleration = 0;
                                break;

                            case "w":
                            case "W":
                                acceleration = 0.5;
                                break;

                            case "s":
                            case "S":
                                acceleration = -0.2;
                                break;

                            case "e":
                            case "E":
                                /* Items Usage
                                 * little recap on how items work on our Mario Kart:
                                 * - banana: if you use this object you will leave a banane peel on the race track
                                 *              where enemies (or even yourself!) can trip and spin
                                 * - red shell: if used and if there are enemies in front of you, it will follow and hit one of them
                                 *                  otherwise, it will act like a green shell
                                 * - green shell: if used, it follows a straight line trajectory and can hit enemies if encountered
                                 *   (N.B. the collisions with shells on a straight line have been held above together with the other lethal items)
                                 * - mushroom: it is the only good items here, if used, it will give a huge sprint for some seconds
                                 * 
                                 * Let's implement these characteristics.
                                */
                                if (item && (item.position.y == 4 || item.position.y == 4.5)){
                                    if(this.item_name == 'banana'){
                                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mk64_banana.wav", scene, function(){
                                            soundDrop.play();
                                        });
                                        item.position.y = 0.95;
                                        posx = item.position.x;
                                        posy = item.position.y;
                                        posz = item.position.z;                  
                                        lethalItems.push(item);
                                        item = null;
                                        
                                        // this makes the item handling works: if we leave an item because we
                                        // hit another item box, we can set this interval to move far away from
                                        // the item and to not be hitten by it
                                        setTimeout(function(){
                                            lethalItemPos.push([posx, posy, posz])
                                        }, 500);

                                    }
                                    else if (this.item_name == 'red_shell'){
                                        const soundShell = new BABYLON.Sound("soundShell", "sounds/shell.mp3", scene, function(){
                                            soundShell.play();
                                        });
                                        item.position.y = 0.95;
                                        throwed = 1.8;
                                        
                                        // for simplificity we will hit the first car in front of us
                                        targetCar = carsFront[0];
                                        // we need that the shell reduces its distance from targetCar
                                        if (targetCar){
                                            // moreover we will position the red shell aligned to the target car, in this way it will always
                                            // go straight but it will ALMOST certainly hit the car
                                            // N.B. this is another further simplification but it is more easy to implement
                                            if ((car.position.x > -16 && car.position.x < 15) || (car.position.x > 603 && car.position.x < 635)) item.position.x = targetCar.position.x;
                                            else item.position.z = targetCar.position.z;
                                        }
                                    }
                                    else if (this.item_name == 'green_shell'){
                                        const soundShell = new BABYLON.Sound("soundShell", "sounds/shell.mp3", scene, function(){
                                            soundShell.play();
                                        });
                                        item.position.y = 0.95;
                                        throwed = 1.8;
                                    }
                                    else if (this.item_name == 'mushroom'){
                                        const soundMush = new BABYLON.Sound("soundMush", "sounds/mushroom.mp3", scene, function(){
                                            soundMush.play();
                                        });
                                        var repeat = true;
                                        soundMush.onended = function(){
                                            if (repeat){
                                                soundMush.play();
                                                repeat = false;
                                            }
                                        }
                                        sprint = 1;
                                        item.dispose();
                                        item = null;
                                    }
                                }
                                break;

                            case "r":
                            case "R":
                                window.location.reload()
                                break;

                            case "c":
                            case "C":
                                if(game_ended){
                                    if(parent.document.URL.indexOf('&') > 1)
                                        window.location.href = "bowserCastle.html?character="+character_name+"&score="+score.toString();
                                    else
                                        window.location.href = "index.html";
                                }
                                break;   

                            default:
                                acceleration = 0;
                        }
                    break;
                }
            });
        }
        
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>
