<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Bowser's Castle</title>
        <link rel="icon" href="textures/mario_head.png" type="image/png" />

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #fps {
                position: absolute;
                background-color: red;
                border: 1px solid white;
                text-align: center;
                font-size: 16px;
                color: white;
                top: 15px;
                left: 10px;
                width: 60px;
                height: 20px;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    </head>

   <body>
    <div id="fps">0 fps</div>
    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
        // show fps
        var fps_interface = document.getElementById("fps");
        // better have some global variables to have them always available
        var car, car1, car2, car3, item;
        // front/rear left/right wheels for the user car
        var wheelFL, wheelFR, wheelRL, wheelRR;
        // arrays for the item boxes
        var itemBoxPos = [], itemBoxes = [];
        // arrays for 'negative' items
        var lethalItemPos = [], lethalItems = [];
        // arrays for 'positive' items
        var goodItemPos = [], goodItems = [];
        // arrays for the paths for the computer-controlled cars
        var points1 = [], points2 = [], points3 = [];
        
        // arrays to store the checkpoints in case of falls from the race track ...
        var ckpts = [];
        // ... together with the index of the current checkpoints that will be incremented every time we take an item
        var index = 0;
        var posX, posZ;

        var raceTime = 0;

        var groundMat, streetMat, bleachersMat;
        var update_done = false, game_ended = false;

        if(parent.document.URL.indexOf('&') > 1){
                var character_name = parent.document.URL.substring(parent.document.URL.indexOf('?')+11, parent.document.URL.indexOf('&'));
                var score = parseInt(parent.document.URL.substring(parent.document.URL.indexOf('&')+7, parent.document.URL.length));
        }
        else
            var character_name = parent.document.URL.substring(parent.document.URL.indexOf('?')+11, parent.document.URL.length);

        const createScene = () => {
            
            const scene = new BABYLON.Scene(engine);
            const camera = new BABYLON.FollowCamera("camera", new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            /* let's describe briefly how we have imagined this environment:
             * we are INSIDE the castle of Bowser, therefore there is no sky (SkyBox and SkyMaterial on BabylonJS)
             * moreover, we want to render a slightly dark environment typical of a closed scene: we have only one light
             * on the imaginary ceiling of the castle that emits lights like a lamp: a HemispericLight is again
             * appropriate for this case
            */
            // hemispheric light pointing downward => (0, 1, 0) ...
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            // ... placed on the ceiling (for the position see the 'castle' instance below)
            light.position = new BABYLON.Vector3(325, 642, -60);
            // a darker place, but not too dark...
            light.diffuse = new BABYLON.Color3(0.85, 0.85, 0.85);
            light.specular = new BABYLON.Color3(1, 1, 1);
            light.intensity = 1;
            light.groundColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            
            // lighting - 1
            // ambient color requires the ambient color of the scene to be set
            scene.ambientColor = new BABYLON.Color3(0, 0, 0);

            // we can define a big semi-sphere around the ground to simulate the castle
            const castle= BABYLON.MeshBuilder.CreateSphere("castle", {slice: 0.5, diameter: 1300, sideOrientation: BABYLON.Mesh.DOUBLESIDE});
            castle.position.z = -60;
            castle.position.x = 325;
            castle.position.y = -8;
            // simple black texture to the castle
            const castleMat = new BABYLON.StandardMaterial("castleMat");
            castleMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            castle.material = castleMat;

            // lava material for the ground
            var lavaMaterial = new BABYLON.LavaMaterial("lava", scene);
            lavaMaterial.noiseTexture = new BABYLON.Texture("textures/bump.jpg", scene);
            lavaMaterial.diffuseTexture = new BABYLON.Texture("textures/magma.jpg", scene);
            
            const ground = BABYLON.MeshBuilder.CreateDisc("ground", {radius: 650}, scene); // radius = 650 = castle diameter / 2 = 1300 / 2
            ground.rotation.x = Math.PI / 2;
            // same position on the castle
            ground.position.x = 325;
            ground.position.y = -2.5;
            ground.position.z = -60;
            ground.material = lavaMaterial;
            lavaMaterial.unlit = true;
            // lava perturbations speed
            lavaMaterial.speed = 0.5; 
            lavaMaterial.fogColor = new BABYLON.Color3(1, 0.55, 0.15);

            // building the environment around the street
            // finish line
            BABYLON.SceneLoader.ImportMeshAsync("", "models/finish_line/", "scene.gltf", scene).then((result) => {
                finish = result.meshes[0];
                finish.scaling = new BABYLON.Vector3(-1.1, 0.8, 0.9);
                finish.position.y = -1;
                finish.position.x = 650
                finish.position.z = 150;

                finish.rotation.y = Math.PI;
                finish.rotationQuaternion = null;

            });

            // thwomps
            BABYLON.SceneLoader.ImportMeshAsync("", "models/thwomp/", "scene.gltf", scene).then((result) => {
                // thwomps in first rettilineo
                thwomp = result.meshes[0];
                thwomp.scaling = new BABYLON.Vector3(1, 1, 1);
                thwomp.position.z = 250;
                thwomp.position.y = 5;
                thwomp.position.x = 620;
                thwomp.rotation.y = Math.PI/180*160;
                thwomp.rotationQuaternion = null;
                
                other_thwomp = this.thwomp.clone()
                other_thwomp.position.x += 60;
                other_thwomp.rotation.y = Math.PI/180*200;

                other_thwomp = this.thwomp.clone()
                other_thwomp.position.z = -340;

                other_thwomp = this.thwomp.clone()
                other_thwomp.position.x += 60;
                other_thwomp.position.z = -340;
                other_thwomp.rotation.y = Math.PI/180*200;
                
                // far thwomps (in rettilineo 4 and 6)
                other_thwomp = this.thwomp.clone()
                other_thwomp.position.x = 250;
                other_thwomp.position.z = 68;
                other_thwomp.rotation.y = Math.PI/180*110;

                other_thwomp = this.thwomp.clone()
                other_thwomp.position.x = 250;
                other_thwomp.position.z = 10;
                other_thwomp.rotation.y = Math.PI/180*70;
                
                other_thwomp = this.thwomp.clone()
                other_thwomp.position.x = 310;
                other_thwomp.position.z = -141;
                other_thwomp.rotation.y = Math.PI/180*250;

                other_thwomp = this.thwomp.clone()
                other_thwomp.position.x = 310;
                other_thwomp.position.z = -199;
                other_thwomp.rotation.y = Math.PI/180*290;
            });

            // chain chomps
            BABYLON.SceneLoader.ImportMeshAsync("", "models/chain_chomp/", "scene.gltf", scene).then((result) => {
                // chain in 3rd rettilineo
                chain = result.meshes[0];
                chain.scaling = new BABYLON.Vector3(0.15, 0.15, 0.15);
                chain.position.z = 80;
                chain.position.y = 8;
                chain.position.x = 430;
                chain.rotation.y = Math.PI/180*250;
                chain.rotation.z = Math.PI/180*350;
                chain.rotationQuaternion = null;
                
                // chain in 7th rettilineo
                other_chain = this.chain.clone()
                other_chain.position.x = 377;
                other_chain.position.z = -380;
                other_chain.rotation.y = Math.PI/180*290;
            });

            // bowser's statue
            BABYLON.SceneLoader.ImportMeshAsync("", "models/bowser_statue/", "scene.gltf", scene).then((result) => {
                statue = result.meshes[0];
                statue.scaling = new BABYLON.Vector3(0.3, 0.3, 0.3);
                statue.position.z = -50;
                statue.position.y = 35;
                statue.position.x = 530;
                statue.rotation.y = Math.PI*3/2;
                statue.rotationQuaternion = null;
            });

            // building the street
            streetMat = new BABYLON.StandardMaterial("streetMat");
            streetMat.diffuseTexture = new BABYLON.Texture("textures/stone.jpg");
            streetMat.diffuseTexture.hasAlpha = true;
            
            const street = BABYLON.MeshBuilder.CreateBox("street", {width:30, height:19, depth:1});
            street.rotation.x = Math.PI / 2;
            street.material = streetMat;
            street.position.x = 650;
            street.position.z = -450;
            var pos_z = street.position.z + 19;
            var pos_x = street.position.x + 10;

            const small_piece = BABYLON.MeshBuilder.CreateBox("street", {width:30, height:3, depth:1});
            small_piece.rotation.x = Math.PI / 2;
            small_piece.material = streetMat;
            small_piece.position.x = 650;
            small_piece.position.z = -461;

            // first rettilineo
            for (i=0; i<40; i++){
                other_street = street.clone()
                other_street.position.z = pos_z;
                pos_z += 19;
            }

            // second rettilineo
            pos_z -= 24.5;
            pos_x -= 34.5;
            for (i=0; i<13; i++){
                other_street = street.clone()
                other_street.rotation.y = Math.PI / 2;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_x -= 19;
            }

            // third rettilineo
            pos_z -= 24.5;
            pos_x += 24.5;
            for (i=0; i<14; i++){
                other_street = street.clone()
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_z -= 19;
            }

            // 4th rettilineo
            pos_z += 24.5;
            pos_x -= 24.5;
            for (i=0; i<13; i++){
                other_street = street.clone()
                other_street.rotation.y = Math.PI / 2;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_x -= 19;
            }

            // 5th rettilineo
            pos_z -= 24.5;
            pos_x += 24.5;
            for (i=0; i<11; i++){
                other_street = street.clone()
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_z -= 19;
            }

            // 6th rettilineo
            pos_z += 24.5;
            pos_x += 24.5;
            for (i=0; i<13; i++){
                other_street = street.clone()
                other_street.rotation.y = Math.PI / 2;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_x += 19;
            }

            // 7th rettilineo
            pos_z -= 24.5;
            pos_x -= 24.5;
            for (i=0; i<13; i++){
                other_street = street.clone()
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_z -= 19;
            }

            // 8th rettilineo
            pos_z -= 5.5;
            pos_x -= 5.5;
            for (i=0; i<13; i++){
                other_street = street.clone()
                other_street.rotation.y = Math.PI / 2;
                other_street.position.z = pos_z;
                other_street.position.x = pos_x;
                pos_x += 19;
            }

            // user's car
            if(character_name == 'mario')
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_mario/", "scene.gltf", scene).then((result) => {
                    car = result.meshes[0];
                    car.scaling = new BABYLON.Vector3(2.2, 2.2, -2.2);
                    car.position.z = 120;
                    car.position.x = 645;
                    car.position.y = 0.7;
                    car.rotationQuaternion = null;
                    car.rotation.y = Math.PI;
                    // the camera will follow the car with this
                    camera.lockedTarget = car;

                    /*-----------------------Wheel------------------------------------------*/ 
	
                    // 'our' Wheel Material 
                    var wheelMaterial = new BABYLON.StandardMaterial("wheel_mat", scene);
                    var wheelTexture = new BABYLON.Texture("http://i.imgur.com/ZUWbT6L.png", scene);
                    wheelMaterial.diffuseTexture = wheelTexture;

                    //Set color for wheel tread as black
                    var faceColors=[];
                    faceColors[1] = new BABYLON.Color3(0,0,0);

                    //set texture for flat face of wheel 
                    var faceUV =[];
                    faceUV[0] = new BABYLON.Vector4(0,0,1,1);
                    faceUV[2] = new BABYLON.Vector4(0,0,1,1);

                    //create wheel and apply material
                    wheelFL = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter: 3, height: 1, tessellation: 24, faceColors:faceColors, faceUV:faceUV}, scene);
                    wheelFL.material = wheelMaterial;
                    
                    wheelFL.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.WORLD);
                    wheelFL.rotate(BABYLON.Axis.Y, Math.PI/2, BABYLON.Space.WORLD);
                    
                    wheelFL.position = new BABYLON.Vector3(0.4, 0.2, 0.45);
                    wheelFL.scaling = new BABYLON.Vector3(0.12, 0.22, 0.12);

                    // CRUCIAL LINE!!!
                    wheelFL.parent = car;

                    // other wheels
                    wheelFR = wheelFL.clone();
                    wheelFR.position.x = -0.4;

                    wheelRL = wheelFL.clone();
                    wheelRL.position = new BABYLON.Vector3(0.45, 0.2, -0.35);
                    wheelRL.scaling = new BABYLON.Vector3(0.15, 0.25, 0.15);
                    
                    wheelRR = wheelFL.clone();
                    wheelRR.position = new BABYLON.Vector3(-0.45, 0.2, -0.35);
                    wheelRR.scaling = new BABYLON.Vector3(0.15, 0.25, 0.15);

                    
                    // dispose does not work -> let's make the original wheels extremely small
                    result.meshes[3].scaling = new BABYLON.Vector3(0.00001, 0.00001, 0.00001);

                });
            else if(character_name == 'toad')
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_toad/", "scene.gltf", scene).then((result) => {
                    car = result.meshes[0];
                    car.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car.position.z = 120;
                    car.position.x = 645;
                    car.position.y = 0.7;
                    car.rotationQuaternion = null;
                    car.rotation.y = Math.PI;
                    camera.lockedTarget = car;

                    /*-----------------------Wheel------------------------------------------*/ 
	
                    // 'our' Wheel Material 
                    var wheelMaterial = new BABYLON.StandardMaterial("wheel_mat", scene);
                    var wheelTexture = new BABYLON.Texture("http://i.imgur.com/ZUWbT6L.png", scene);
                    wheelMaterial.diffuseTexture = wheelTexture;

                    //Set color for wheel tread as black
                    var faceColors=[];
                    faceColors[1] = new BABYLON.Color3(0,0,0);

                    //set texture for flat face of wheel 
                    var faceUV =[];
                    faceUV[0] = new BABYLON.Vector4(0,0,1,1);
                    faceUV[2] = new BABYLON.Vector4(0,0,1,1);

                    //create wheel and apply material
                    wheelFL = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter: 3, height: 1, tessellation: 24, faceColors:faceColors, faceUV:faceUV}, scene);
                    wheelFL.material = wheelMaterial;
                    
                    wheelFL.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.WORLD);
                    wheelFL.rotate(BABYLON.Axis.Y, Math.PI/2, BABYLON.Space.WORLD);
                    
                    wheelFL.position = new BABYLON.Vector3(0.65, 0.2, 1.1);
                    wheelFL.scaling = new BABYLON.Vector3(0.15, 0.25, 0.15);

                    // CRUCIAL LINE!!!
                    wheelFL.parent = car;

                    // other wheels
                    wheelFR = wheelFL.clone();
                    wheelFR.position.x = -0.55;

                    wheelRL = wheelFL.clone();
                    wheelRL.position = new BABYLON.Vector3(0.60, 0.2, 0);
                    
                    wheelRR = wheelFL.clone();
                    wheelRR.position = new BABYLON.Vector3(-0.525, 0.2, 0);
                    
                    // dispose does not work -> let's make the original wheels extremely small
                    //result.meshes[11].position.x = -3;
                    result.meshes[11].scaling = new BABYLON.Vector3(0.00001, 0.00001, 0.00001);
                
                });
            else if(character_name == 'bowser')
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_bowser/", "scene.gltf", scene).then((result) => {
                    car = result.meshes[0];
                    car.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car.position.z = 120;
                    car.position.x = 645;
                    car.position.y = 0.7;
                    car.rotationQuaternion = null;
                    car.rotation.y = Math.PI;
                    camera.lockedTarget = car;

                    /*-----------------------Wheel------------------------------------------*/ 
	
                    // 'our' Wheel Material 
                    var wheelMaterial = new BABYLON.StandardMaterial("wheel_mat", scene);
                    var wheelTexture = new BABYLON.Texture("http://i.imgur.com/ZUWbT6L.png", scene);
                    wheelMaterial.diffuseTexture = wheelTexture;

                    //Set color for wheel tread as black
                    var faceColors=[];
                    faceColors[1] = new BABYLON.Color3(0,0,0);

                    //set texture for flat face of wheel 
                    var faceUV =[];
                    faceUV[0] = new BABYLON.Vector4(0,0,1,1);
                    faceUV[2] = new BABYLON.Vector4(0,0,1,1);

                    //create wheel and apply material
                    wheelFL = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter: 3, height: 1, tessellation: 24, faceColors:faceColors, faceUV:faceUV}, scene);
                    wheelFL.material = wheelMaterial;
                    
                    wheelFL.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.WORLD);
                    wheelFL.rotate(BABYLON.Axis.Y, Math.PI/2, BABYLON.Space.WORLD);
                    
                    wheelFL.position = new BABYLON.Vector3(0.95, 0.3, 1.3);
                    wheelFL.scaling = new BABYLON.Vector3(0.29, 0.49, 0.29);

                    // CRUCIAL LINE!!!
                    wheelFL.parent = car;

                    // other wheels
                    wheelFR = wheelFL.clone();
                    wheelFR.position.x = -1.15;

                    wheelRL = wheelFL.clone();
                    wheelRL.position = new BABYLON.Vector3(0.95, 0.25, -0.25);
                    
                    wheelRR = wheelFL.clone();
                    wheelRR.position = new BABYLON.Vector3(-1.15, 0.25, -0.25);
                    
                    // dispose does not work -> let's make the original wheels extremely small
                    //result.meshes[2].position.x = -3;
                    result.meshes[2].scaling = new BABYLON.Vector3(0.00001, 0.00001, 0.00001);
                
                });
            else // donkey
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_dk/", "scene.gltf", scene).then((result) => {
                    car = result.meshes[0];
                    car.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car.position.z = 120;
                    car.position.x = 645;
                    car.position.y = 0.7;
                    car.rotationQuaternion = null;
                    car.rotation.y = Math.PI;
                    camera.lockedTarget = car;

                    /*-----------------------Wheel------------------------------------------*/ 
	
                    // 'our' Wheel Material 
                    var wheelMaterial = new BABYLON.StandardMaterial("wheel_mat", scene);
                    var wheelTexture = new BABYLON.Texture("http://i.imgur.com/ZUWbT6L.png", scene);
                    wheelMaterial.diffuseTexture = wheelTexture;

                    //Set color for wheel tread as black
                    var faceColors=[];
                    faceColors[1] = new BABYLON.Color3(0,0,0);

                    //set texture for flat face of wheel 
                    var faceUV =[];
                    faceUV[0] = new BABYLON.Vector4(0,0,1,1);
                    faceUV[2] = new BABYLON.Vector4(0,0,1,1);

                    //create wheel and apply material
                    wheelFL = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter: 3, height: 1, tessellation: 24, faceColors:faceColors, faceUV:faceUV}, scene);
                    wheelFL.material = wheelMaterial;
                    
                    wheelFL.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.WORLD);
                    wheelFL.rotate(BABYLON.Axis.Y, Math.PI/2, BABYLON.Space.WORLD);
                    
                    wheelFL.position = new BABYLON.Vector3(0.6, 0.1, 1.2);
                    wheelFL.scaling = new BABYLON.Vector3(0.12, 0.22, 0.12);

                    // CRUCIAL LINE!!!
                    wheelFL.parent = car;

                    // other wheels
                    wheelFR = wheelFL.clone();
                    wheelFR.position.x = -0.6;

                    wheelRL = wheelFL.clone();
                    wheelRL.position = new BABYLON.Vector3(0.6, 0.1, 0.5);
                    
                    wheelRR = wheelFL.clone();
                    wheelRR.position = new BABYLON.Vector3(-0.6, 0.1, 0.5);
                    
                    // dispose does not work -> let's make the original wheels extremely small
                    //result.meshes[2].position.x = -3;
                    result.meshes[2].scaling = new BABYLON.Vector3(0.00001, 0.00001, 0.00001);
                
                });
            camera.rotationOffset = 180;
            
            // three cpu's cars
            points1.push(new BABYLON.Vector3(655, 0.7, 126.67));
            if(character_name!='toad'){
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_toad/", "scene.gltf", scene).then((result) => {
                    car1 = result.meshes[0];
                    car1.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car1.position.x = 655;
                    car1.position.y = 0.7;
                    car1.position.z = 126.67;
                    car1.rotationQuaternion = null;
                    car1.rotation.y = Math.PI;
                    car1.lap = 1;
                    car1.half_lap = false;
                });
            }
            else{
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_mario/", "scene.gltf", scene).then((result) => {
                    car1 = result.meshes[0];
                    car1.scaling = new BABYLON.Vector3(2.2, 2.2, -2.2);
                    car1.position.x = 655;
                    car1.position.y = 0.7;
                    car1.position.z = 126.67;
                    car1.rotationQuaternion = null;
                    car1.rotation.y = Math.PI;
                    car1.lap = 1;
                    car1.half_lap = false;
                });
            }

            points2.push(new BABYLON.Vector3(645, 0.7, 132.37));
            if(character_name!='bowser'){
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_bowser/", "scene.gltf", scene).then((result) => {
                    car2 = result.meshes[0];
                    car2.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car2.position.x = 645;
                    car2.position.y = 0.7;
                    car2.position.z = 132.37;
                    car2.rotationQuaternion = null;
                    car2.rotation.y = Math.PI;
                    car2.lap = 1;
                    car2.half_lap = false;
                });
            }
            else{
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_mario/", "scene.gltf", scene).then((result) => {
                    car2 = result.meshes[0];
                    car2.scaling = new BABYLON.Vector3(2.2, 2.2, -2.2);
                    car2.position.x = 645;
                    car2.position.y = 0.7;
                    car2.position.z = 132.37;
                    car2.rotationQuaternion = null;
                    car2.rotation.y = Math.PI;
                    car2.lap = 1;
                    car2.half_lap = false;
                });
            }

            points3.push(new BABYLON.Vector3(655, 0.7, 140));
            if(character_name!='donkey'){ 
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_dk/", "scene.gltf", scene).then((result) => {
                    car3 = result.meshes[0];
                    car3.scaling = new BABYLON.Vector3(1.3, 1.3, -1.3);
                    car3.position.x = 655;
                    car3.position.y = 0.7;
                    car3.position.z = 140;
                    car3.rotationQuaternion = null;
                    car3.rotation.y = Math.PI;
                    car3.lap = 1;
                    car3.half_lap = false;
                });
            }
            else{
                BABYLON.SceneLoader.ImportMeshAsync("", "models/kart_mario/", "scene.gltf", scene).then((result) => {
                    car3 = result.meshes[0];
                    car3.scaling = new BABYLON.Vector3(2.2, 2.2, -2.2);
                    car3.position.x = 655;
                    car3.position.y = 0.7;
                    car3.position.z = 140;
                    car3.rotationQuaternion = null;
                    car3.rotation.y = Math.PI;
                    car3.lap = 1;
                    car3.half_lap = false;
                });
            }
            ckpts.push(new BABYLON.Vector4(645, 0.7, 120, Math.PI));

            // creating the item boxes and pushing points for the cpu's path
            createItemBoxLine(scene, [643, 1, 230], true, false);
            points1.push(new BABYLON.Vector3(655, 1, 303)); // white
            points2.push(new BABYLON.Vector3(650, 1, 301)); // red
            points3.push(new BABYLON.Vector3(660, 1, 305)); // green

            createItemBoxLine(scene, [530, 1, 297], false, true);
            points1.push(new BABYLON.Vector3(405, 1, 303)); // white
            points2.push(new BABYLON.Vector3(410, 1, 301)); // red
            points3.push(new BABYLON.Vector3(400, 1, 305)); // green
            
            createItemBoxLine(scene, [397, 1, 180], true, true);
            points1.push(new BABYLON.Vector3(405, 1, 41)); // white
            points2.push(new BABYLON.Vector3(410, 1, 37)); // red
            points3.push(new BABYLON.Vector3(400, 1, 45)); // green

            createItemBoxLine(scene, [280, 1, 32], false, true);
            points1.push(new BABYLON.Vector3(155, 1, 37)); // white
            points2.push(new BABYLON.Vector3(160, 1, 33)); // red
            points3.push(new BABYLON.Vector3(150, 1, 41)); // green

            createItemBoxLine(scene, [150, 1, -70], true, true);
            points1.push(new BABYLON.Vector3(158, 1, -164)); // white
            points2.push(new BABYLON.Vector3(163, 1, -160)); // red
            points3.push(new BABYLON.Vector3(153, 1, -168)); // green

            createItemBoxLine(scene, [280, 1, -177], false, false);
            points1.push(new BABYLON.Vector3(405, 1, -166)); // white
            points2.push(new BABYLON.Vector3(407, 1, -161)); // red
            points3.push(new BABYLON.Vector3(397, 1, -171)); // green

            createItemBoxLine(scene, [397, 1, -320], true, true);
            points1.push(new BABYLON.Vector3(405, 1, -440)); // white
            points2.push(new BABYLON.Vector3(407, 1, -435)); // red
            points3.push(new BABYLON.Vector3(397, 1, -445)); // green

            createItemBoxLine(scene, [530, 1, -454], false, false);
            points1.push(new BABYLON.Vector3(643, 1, -440)); // white
            points2.push(new BABYLON.Vector3(638, 1, -435)); // red
            points3.push(new BABYLON.Vector3(648, 1, -445)); // green

            createItemBoxLine(scene, [643, 1, -370], true, false);
            createItemBoxLine(scene, [643, 1, -200], true, false);
            createItemBoxLine(scene, [643, 1, 0], true, false);

            points1.push(points1[0]); // push to close path
            points2.push(points2[0]); // push to close path
            points3.push(points3[0]); // push to close path

            return scene;
        };

        const scene = createScene(); // Call the createScene function

        // initial button
        var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        var button = BABYLON.GUI.Button.CreateImageButton("but", "Welcome to Bowser's Castle!        \nClick to start the race.             ", "");
        button.height = "100px";
        button.width = "350px";
        button.background = 'red';
        button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        advancedTexture.addControl(button);
        button.pointerDownAnimation = () => {
            advancedTexture.dispose();
            startSounds();
        };

        function startSounds(){
            // adding sounds
            const soundStart = new BABYLON.Sound("soundStart", "sounds/mk64_racestart.wav", scene, function(){
                soundStart.play();
            });

            // once the start sound is over we proceed with the countdown
            soundStart.onended = function(){

                // countdown for the race to start
                var countTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                var i = 3; // seconds
                var textBlock = new BABYLON.GUI.TextBlock("text", new String(i));   
                textBlock.color = "orange";
                textBlock.fontSize = 150;
                textBlock.fontFamily = "impact";
                
                countTexture.addControl(textBlock);
                var handle = window.setInterval(() => {
                    i--;
                    textBlock.text = new String(i)

                    if (i === 0) {
                        textBlock.text = "GO!"
                    }

                    if (i == -1){
                        window.clearInterval(handle);

                        textBlock.dispose();
                        countTexture.dispose();
                    }
                }, 890);
                
                const countSound = new BABYLON.Sound("countSound", "sounds/mk64_countdown.wav", scene, function(){
                    countSound.play();
                });
                
                countSound.onended = function(){
                    startRace(car);
                }
            };
        }

        // this fn creates a set of four aligned (along x- or z-axis) item boxes
        function createItemBoxLine(scene, starting_pos, alignedX, opposed){
            if(alignedX&&!opposed){
                points2.push(new BABYLON.Vector3(starting_pos[0]+4.5, starting_pos[1], starting_pos[2]));
                points1.push(new BABYLON.Vector3(starting_pos[0]+9, starting_pos[1], starting_pos[2]));
                points3.push(new BABYLON.Vector3(starting_pos[0]+13.5, starting_pos[1], starting_pos[2]));

                ckpts.push(new BABYLON.Vector4(starting_pos[0]+9, starting_pos[1], starting_pos[2]-20, Math.PI));
            }
            else if(alignedX&&opposed){
                points3.push(new BABYLON.Vector3(starting_pos[0]+4.5, starting_pos[1], starting_pos[2]));
                points1.push(new BABYLON.Vector3(starting_pos[0]+9, starting_pos[1], starting_pos[2]));
                points2.push(new BABYLON.Vector3(starting_pos[0]+13.5, starting_pos[1], starting_pos[2]));

                ckpts.push(new BABYLON.Vector4(starting_pos[0]+9, starting_pos[1], starting_pos[2]+20, 2*Math.PI));
            }
            else if(!alignedX&&opposed){
                points1.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+9));
                points3.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+13.5));
                points2.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+4.5));

                ckpts.push(new BABYLON.Vector4(starting_pos[0]+20, starting_pos[1], starting_pos[2]+9, 5*Math.PI/2));
            }
            else{
                points1.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+9));
                points2.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+13.5));
                points3.push(new BABYLON.Vector3(starting_pos[0], starting_pos[1], starting_pos[2]+4.5));

                ckpts.push(new BABYLON.Vector4(starting_pos[0]-20, starting_pos[1], starting_pos[2]+9, 3*Math.PI/2));
            }
            BABYLON.SceneLoader.ImportMeshAsync("", "models/item_box/", "scene.gltf", scene).then((result) => {
                itemBox = result.meshes[0];
                itemBox.scaling = new BABYLON.Vector3(0.05, 0.05, 0.05);
                itemBox.position.z = starting_pos[2];
                itemBox.position.y = starting_pos[1];
                itemBox.position.x = starting_pos[0];
                itemBox.rotationQuaternion = null;
                //itemBox.alpha = 0.1;

                itemBoxPos.push([itemBox.position.x, itemBox.position.y, itemBox.position.z]);
                itemBoxes.push(itemBox);

                otherBox1 = itemBox.clone();
                otherBox2 = itemBox.clone();
                otherBox3 = itemBox.clone();

                if (alignedX){
                    otherBox1.position.x = itemBox.position.x + 4.5;
                    otherBox2.position.x = itemBox.position.x + 9;
                    otherBox3.position.x = itemBox.position.x + 13.5;
                }
                else{
                    otherBox1.position.z = itemBox.position.z + 4.5;
                    otherBox2.position.z = itemBox.position.z + 9;
                    otherBox3.position.z = itemBox.position.z + 13.5;
                }    
                itemBoxPos.push([otherBox1.position.x, otherBox1.position.y, otherBox1.position.z]);
                itemBoxPos.push([otherBox2.position.x, otherBox2.position.y, otherBox2.position.z]);
                itemBoxPos.push([otherBox3.position.x, otherBox3.position.y, otherBox3.position.z]);

                itemBoxes.push(otherBox1);
                itemBoxes.push(otherBox2);
                itemBoxes.push(otherBox3);

                // for the path that the other cars have to follow we can use the position
                // of the instantiated item boxes as reference points: the cars will pass though
                // one on the four aligned box in every set above
            });
        }

        // we need to distinguish a positive and a negative item
        var positiveItem = false;

        // before use/throw the object we have it 'attached' to the car
        function createItem(name){
            var previous_item = item;
            if (name == 'banana'){
                if (previous_item){
                    posx = previous_item.position.x;
                    posy = previous_item.position.y;
                    posz = previous_item.position.z;
                    if (positiveItem){
                        goodItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            goodItemPos.push([posx, posy, posz])
                            
                        }, 500);

                    }
                    else {        
                        lethalItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            lethalItemPos.push([posx, posy, posz])
                            
                        }, 500);
                    }
                }
                item_name = 'banana';
                const soundItems = new BABYLON.Sound("soundItems", "sounds/items.mp3", scene, function(){
                    soundItems.play();
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "models/banana/", "scene.gltf", scene).then((result) => {
                    if(previous_item){
                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mk64_banana.wav", scene, function(){
                            soundDrop.play();
                        });
                    }
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.002, 0.002, 0.002);
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                    item.position.y = -4.5;
                    positiveItem = false;
                    soundItems.onended = function(){
                        if(item)
                            item.position.y = 4.5;
                    }
                });
            }
            else if (name == 'red_shell'){
                if (previous_item){
                    posx = previous_item.position.x;
                    posy = previous_item.position.y;
                    posz = previous_item.position.z;                  

                    if (positiveItem){
                        goodItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            goodItemPos.push([posx, posy, posz])
                            
                        }, 500);

                    }
                    else {        
                        lethalItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            lethalItemPos.push([posx, posy, posz])
                            
                        }, 500);
                    }
                }
                item_name = 'red_shell';
                const soundItems = new BABYLON.Sound("soundItems", "sounds/items.mp3", scene, function(){
                    soundItems.play();
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "models/red_shell/", "scene.gltf", scene).then((result) => {
                    if(previous_item){
                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mouseover.mp3", scene, function(){
                            soundDrop.play();
                        });
                    }
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.15, 0.15, 0.15);
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                    item.position.y = -4.5;
                    positiveItem = false;
                    soundItems.onended = function(){
                        if(item)
                            item.position.y = 4.5;
                    }
                });
            }
            else if (name == 'mushroom'){
                if (previous_item){
                    posx = previous_item.position.x;
                    posy = previous_item.position.y;
                    posz = previous_item.position.z;                  

                    if (positiveItem){
                        goodItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            goodItemPos.push([posx, posy, posz])
                            
                        }, 500);

                    }
                    else {        
                        lethalItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            lethalItemPos.push([posx, posy, posz])
                            
                        }, 500);
                    } 
                }
                item_name = 'mushroom';
                const soundItems = new BABYLON.Sound("soundItems", "sounds/items.mp3", scene, function(){
                    soundItems.play();
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "models/mushroom/", "scene.gltf", scene).then((result) => {
                    if(previous_item){
                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mouseover.mp3", scene, function(){
                            soundDrop.play();
                        });
                    }
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
                    item.position.y = -4.5;
                    item.rotationQuaternion = null;
                    item.rotation.y = Math.PI / 2;
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                    positiveItem = true;
                    soundItems.onended = function(){
                        if(item)
                            item.position.y = 4.5;
                    }
                });
            }
            else if (name == 'green_shell'){
                if (previous_item){
                    posx = previous_item.position.x;
                    posy = previous_item.position.y;
                    posz = previous_item.position.z;                  

                    if (positiveItem){
                        goodItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            goodItemPos.push([posx, posy, posz])
                            
                        }, 500);

                    }
                    else {        
                        lethalItems.push(previous_item);

                        // this makes the item handling works: if we leave an item because we
                        // hit another item box, we can set this interval to move far away from
                        // the item and to not be hitten by it
                        setTimeout(function(){
                            lethalItemPos.push([posx, posy, posz])
                            
                        }, 500);
                    } 
                }
                item_name = 'green_shell';
                const soundItems = new BABYLON.Sound("soundItems", "sounds/items.mp3", scene, function(){
                    soundItems.play();
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "models/green_shell/", "scene.gltf", scene).then((result) => {
                    if(previous_item){
                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mouseover.mp3", scene, function(){
                            soundDrop.play();
                        });
                    }
                    item = result.meshes[0];
                    item.scaling = new BABYLON.Vector3(0.005, 0.005, 0.005);
                    item.position.y = -4.5;
                    item.position.z = car.position.z;
                    item.position.x = car.position.x;
                    item.rotationQuaternion = null;
                    item.rotation.y = Math.PI / 2;
                    positiveItem = false;
                    soundItems.onended = function(){
                        if(item)
                            item.position.y = 4;
                    }
                });
            }
            else {
                console.log("Unsopperted item to be created! Please, debug.")
            }
        }

        var lap = 1;
        // arrays to store the cars in front of us or behind us
        var carsBehind = [], carsFront = [];

        function startRace(car) {
            var startTime = new Date().getTime();
            angle = car.rotation.y - Math.PI;

            // array to store all the cars involved in the race
            // REMEMBER: index = 0 -> our car, index > 0 -> 'enemies'
            var carsAll = [car, car1, car2, car3];

            // at the beginning we are 4th, therefore:
            carsFront = [car1, car2, car3];
            // moreover, we will always use the carsFront array to determine our position during the race, in fact:
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            // user interface
            let x1 = new BABYLON.GUI.TextBlock('TextBlock', ''); 
            x1.fontSize = 50;
            x1.fontFamily = "impact";
            x1.color = "yellow";
            var rect1 = new BABYLON.GUI.Rectangle();
            rect1.width = 0.23;
            rect1.height = 0.21;
            rect1.paddingTop = '3%';
            rect1.paddingRight = '3%';
            rect1.horizontalAlignment = 1;
            rect1.verticalAlignment = 0;
            rect1.cornerRadius = 10;
            rect1.color = "black";
            rect1.thickness = 4;
            rect1.background = "red";
            advancedTexture.addControl(rect1);
            rect1.addControl(x1);

            let x2 = new BABYLON.GUI.TextBlock('TextBlock', ''); 
            x2.fontSize = 50;
            x2.fontFamily = "impact";
            x2.color = "yellow";
            var rect2 = new BABYLON.GUI.Rectangle();
            rect2.width = 0.18;
            rect2.height = 0.13;
            rect2.paddingBottom = '3%';
            rect2.paddingLeft = '3%';
            rect2.horizontalAlignment = 0;
            rect2.verticalAlignment = 1;
            rect2.cornerRadius = 10;
            rect2.color = "black";
            rect2.thickness = 4;
            rect2.background = "red";
            advancedTexture.addControl(rect2);
            rect2.addControl(x2);

            x1.text = 'Lap ' + String(lap) + '/3' + '\n Time: ' + String(0);
            x2.text = 'Position: ' + String(carsFront.length + 1);

            // these variables handle the collisions with the (horizontal/vertical) walls
            var wall1 = true, wall2 = true, wall3 = true, wall4 = true, wall5 = true, wall6 = true, wall7 = true, wall8 = true;

            // let's start the soundtrack of the Bowser's Castle
            const bowserSound = new BABYLON.Sound("bowserSound", "sounds/Bowser's Castle.mp3", scene, null, {
                loop: true,
                autoplay: true,
                volume: 0.9
            });

            // here we handle the animation of the other three cars in the race
            const animCarX1 = new BABYLON.Animation("canAnimationx1", "position.x", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            const animCarZ1 = new BABYLON.Animation("canAnimationz1", "position.z", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            
            const animCarX2 = new BABYLON.Animation("canAnimationx2", "position.x", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            const animCarZ2 = new BABYLON.Animation("canAnimationz2", "position.z", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            const animCarX3 = new BABYLON.Animation("canAnimationx3", "position.x", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            const animCarZ3 = new BABYLON.Animation("canAnimationz3", "position.z", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            const rotCar = new BABYLON.Animation("rotAnimationz1", "rotation.y", 55, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            const carKeysX1 = [];
            const carKeysZ1 = [];
            
            const carKeysX2 = [];
            const carKeysZ2 = [];

            const carKeysX3 = [];
            const carKeysZ3 = [];

            const rotKeys = [];

            frame = 0;
            for (j=0; j<points1.length; j++){
                carKeysX1.push({
                    frame: frame,
                    value: points1[j].x
                });
                carKeysZ1.push({
                    frame: frame,
                    value: points1[j].z
                });

                carKeysX2.push({
                    frame: frame,
                    value: points2[j].x
                });
                carKeysZ2.push({
                    frame: frame,
                    value: points2[j].z
                });

                carKeysX3.push({
                    frame: frame,
                    value: points3[j].x
                });
                carKeysZ3.push({
                    frame: frame,
                    value: points3[j].z
                });

                // rotation animation
                if(j == 0){
                    rotKeys.push({
                        frame: frame,
                        value:  Math.PI
                    });
                }
                else if(j == 2){
                    rotKeys.push({
                        frame: frame,
                        value:  Math.PI/ 2
                    });
                }
                else if(j == 4){
                    rotKeys.push({
                        frame: frame,
                        value:  0
                    });
                }
                else if(j == 6){
                    rotKeys.push({
                        frame: frame,
                        value: Math.PI/2
                    });
                }
                else if(j == 8){
                    rotKeys.push({
                        frame: frame,
                        value: 0
                    });
                }
                else if(j == 10){
                    rotKeys.push({
                        frame: frame,
                        value: -Math.PI/2
                    });
                }
                else if(j == 12){
                    rotKeys.push({
                        frame: frame,
                        value: 0
                    });
                }
                else if(j == 14){
                    rotKeys.push({
                        frame: frame,
                        value: -Math.PI/2
                    });
                }
                else if(j == 16){
                    rotKeys.push({
                        frame: frame,
                        value: -Math.PI
                    });
                }
                else{
                    rotKeys.push({
                        frame: frame,
                        value:  rotKeys[rotKeys.length - 1].value
                    });
                }

                frame += 150;
            }
            animCarX1.setKeys(carKeysX1);
            animCarZ1.setKeys(carKeysZ1);
            rotCar.setKeys(rotKeys);
            
            animCarX2.setKeys(carKeysX2);
            animCarZ2.setKeys(carKeysZ2);

            animCarX3.setKeys(carKeysX3);
            animCarZ3.setKeys(carKeysZ3);

            // we store the animations in some variables to use them if the computer-controlled cars hit a lethal items
            var carAnimation1 = scene.beginDirectAnimation(car1, [animCarX1, animCarZ1, rotCar], 0, frame, true);
            carAnimation1.speedRatio *= 0.97;
            var carAnimation2 = scene.beginDirectAnimation(car2, [animCarX2, animCarZ2, rotCar], 0, frame, true);
            carAnimation2.speedRatio *= 1.03;
            var carAnimation3 = scene.beginDirectAnimation(car3, [animCarX3, animCarZ3, rotCar], 0, frame, true);
            
            // decomment these lines if you want to test the paths of the computer-controlled cars
            // Creation of a lines mesh
            /*
            var lines1 = BABYLON.MeshBuilder.CreateLines("lines", {points: points1}, scene);
            var lines2 = BABYLON.MeshBuilder.CreateLines("lines", {points: points2}, scene);
            lines2.color = new BABYLON.Color3(1, 0, 0);
            var lines3 = BABYLON.MeshBuilder.CreateLines("lines", {points: points3}, scene);
            lines3.color = new BABYLON.Color3(0, 1, 0);
            */

            var base_speed = 0.5;
            // velocity increment when shell is thrown ...
            var throwed = 0;
            // ... but also when a mushroom is used
            var sprint = 0;
            var acceleration = 0;

            // ensures that the user actually follows the track
            var half_lap = false;

            // if we need to reproduce the sound of the fall and to save the current position
            var s = true;
            var pos = true;
            var doAnim = true;

            // timer
            var timer = setInterval(function(){
                if(lap <= 3){
                    x1.text = 'Lap ' + String(lap) + '/3' + '\n Time: ' + String(raceTime);
                }
            }, 10);

            // end game routine
            function endGame(){
                clearInterval(timer);
                carAnimation1.stop();
                carAnimation2.stop();
                carAnimation3.stop();
                game_ended = true;
                setTimeout(function(){
                    var finishTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                    var textBlock = new BABYLON.GUI.TextBlock("text", new String(i));   
                    textBlock.color = "orange";
                    textBlock.fontSize = 150;
                    textBlock.fontFamily = "impact";
                    finishTexture.addControl(textBlock);
                    textBlock.text = "FINISH!";
                    var handle = window.setInterval(() => {
                        window.clearInterval(handle);
                        textBlock.dispose();
                        finishTexture.dispose();
                    }, 2000);

                    final_position = carsFront.length+1;
                    
                    if(final_position == 1)
                        score += 15;
                    else if(final_position == 2)
                        score += 10;
                    else if(final_position == 3)
                        score += 5;
                    else
                        score += 0;

                    setTimeout(function(){
                        var positionTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                        var textBlock = new BABYLON.GUI.TextBlock("text", '');   
                        textBlock.color = "orange";
                        textBlock.fontSize = 150;
                        textBlock.fontFamily = "impact";
                        positionTexture.addControl(textBlock);
                        textBlock.text = "YOU ARRIVED " + String(final_position) + "/4";
                        var handle = window.setInterval(() => {
                            window.clearInterval(handle);
                            textBlock.dispose();
                            positionTexture.dispose();
                        }, 3000);
                    }, 2100);
                    
                    setTimeout(function(){
                        // if grandPrix, next race
                        if(parent.document.URL.indexOf('&') > 1){
                            var scoreTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                            var textBlock = new BABYLON.GUI.TextBlock("text", '');   
                            textBlock.color = "orange";
                            textBlock.fontSize = 150;
                            textBlock.fontFamily = "impact";
                            scoreTexture.addControl(textBlock);
                            textBlock.text = "YOUR CURRENT SCORE IS:\n" + String(score) + "/45\nPress C to continue!";
                            var handle = window.setInterval(() => {
                                window.clearInterval(handle);
                                textBlock.dispose();
                                scoreTexture.dispose();
                            }, 10000);
                        }
                        // else back to menu
                        else{
                            var scoreTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                            var textBlock = new BABYLON.GUI.TextBlock("text", '');   
                            textBlock.color = "orange";
                            textBlock.fontSize = 150;
                            textBlock.fontFamily = "impact";
                            scoreTexture.addControl(textBlock);
                            textBlock.text = "Press C to continue!";
                            var handle = window.setInterval(() => {
                                window.clearInterval(handle);
                                textBlock.dispose();
                                scoreTexture.dispose();
                            }, 10000);
                        }
                    }, 5500);
                }, 1000);
            }

            scene.registerBeforeRender(function () {
                fps_interface.innerHTML = engine.getFps().toFixed() + " fps";

                var currentTime = new Date().getTime();
                raceTime = ((currentTime - startTime)/1000).toFixed(3);

                // collision car-itembox loop
                for (i=0; i<itemBoxPos.length; i++){
                    if(car.position.x < itemBoxPos[i][0]+1.5 && car.position.x > itemBoxPos[i][0]-1.5 && car.position.z < itemBoxPos[i][2]+1.5 && car.position.z > itemBoxPos[i][2]-1.5){
                        if(item)
                            item.position.y = 0.95;
                        // we have four items randomly chosen
                        throwed = 0;
			
                        // 25% for each item
			r = Math.random();
			    
                        if(r < 0.25)
                            createItem('red_shell');
                        
                        else if(r < 0.5)
                            createItem('banana');
                        
                        else if(r < 0.75)
                            createItem('mushroom');
                        
                        else
                            createItem('green_shell');
                        
                        // removing the 'hitten' item box from the arrays of item boxes
                        itemBoxes[i].dispose();
                        itemBoxes.splice(i, 1);
                        itemBoxPos.splice(i, 1);
                        break;
                    }
                }

                // collision with lethal items (moving shells included)
                // we iterate over ALL the cars that can be hitten by one lethal item
                for (var k=0; k<carsAll.length; k++){
                    // collision car-lethals loop: the car passes over a lethal item, it will do a spin (testacoda)
                    for (i=0; i<lethalItemPos.length; i++){
                        if((carsAll[k].position.x < lethalItemPos[i][0]+1.5 && carsAll[k].position.x > lethalItemPos[i][0]-1.5 && carsAll[k].position.z < lethalItemPos[i][2]+1.5 && carsAll[k].position.z > lethalItemPos[i][2]-1.5)
                            || (k>0 && item && throwed > 0 && carsAll[k].position.x < item.position.x+4 && carsAll[k].position.x > item.position.x-4 && carsAll[k].position.z < item.position.z+4 && carsAll[k].position.z > item.position.z-4)){
                            
                            if(k>0 && item && throwed > 0 && carsAll[k].position.x < item.position.x+4 && carsAll[k].position.x > item.position.x-4 && carsAll[k].position.z < item.position.z+4 && carsAll[k].position.z > item.position.z-4){
                                item.dispose();
                                item = null;
                            }

                            // our car
                            if (k == 0){
                                soundHit = new BABYLON.Sound("soundStart", "sounds/mammamia.mp3", scene, function(){
                                    bowserSound.pause();
                                    soundHit.play();
                                });
                                soundHit.onended = function(){
                                    bowserSound.play();
                                }
                            }
                            /* the spin is realized with a combination of three animations:
                            * - carRotation: 'actual' spin
                            * - carStopx: necessary to do not move the car along the x-axis
                            * - carStopz: necessary to do not move the car along the z-axis
                            * without these last two, the car will proceed in its motion
                            */
                            // every animation is composed by key frames
                            var carRotation = new BABYLON.Animation("carRotation", "rotation.y", 10, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                            const keyFramesRot = []; 
                            
                            var carStopx = new BABYLON.Animation("carStopx", "position.x", 10, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                            var carStopz = new BABYLON.Animation("carStopx", "position.z", 10, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                            const keyFramesPosx = [];
                            const keyFramesPosz = [];

                            const initial_rot = carsAll[k].rotation.y;
                            const initial_posx = carsAll[k].position.x;
                            const initial_posz = carsAll[k].position.z;
                            
                            var spin = Math.PI;
                            for (j=0; j<5; j++){
                                keyFramesRot.push({
                                    frame: 5*j,
                                    value: initial_rot + spin
                                });
                                spin += Math.PI;

                                keyFramesPosx.push({
                                    frame: 5*j,
                                    value: initial_posx
                                });
                                keyFramesPosz.push({
                                    frame: 5*j,
                                    value: initial_posz
                                });
                            }
                            keyFramesRot.push({
                                frame: 30,
                                value: initial_rot
                            })
                        
                            carRotation.setKeys(keyFramesRot);
                            carStopx.setKeys(keyFramesPosx);
                            carStopz.setKeys(keyFramesPosz);

                            // for our car we only need to start the animation of the spin ...
                            if (k == 0) scene.beginDirectAnimation(car, [carRotation, carStopx, carStopz], 0, 60, false);
                            // ... while for all the others, we need to pause their motion animations, start the spin and then
                            // we resume their motion AFTER (!!!) the end of the spin -> async + await
                            else if (k == 1){
                                carAnimation1.pause()
                                setTimeout(async () => {
                                    var anim = scene.beginDirectAnimation(car1, [carRotation, carStopx, carStopz], 0, 60, false);
                                    await anim.waitAsync();
                                    carAnimation1.restart();
                                });
                            }
                            else if (k == 2){
                                carAnimation2.pause()
                                setTimeout(async () => {
                                    var anim = scene.beginDirectAnimation(car2, [carRotation, carStopx, carStopz], 0, 60, false);
                                    await anim.waitAsync();
                                    carAnimation2.restart();
                                });
                            }
                            else {
                                carAnimation3.pause()
                                setTimeout(async () => {
                                    var anim = scene.beginDirectAnimation(car3, [carRotation, carStopx, carStopz], 0, 60, false);
                                    await anim.waitAsync();
                                    carAnimation3.restart();
                                });
                            }

                            lethalItems[i].dispose();
                            lethalItems.splice(i, 1);
                            lethalItemPos.splice(i, 1);

                            // only our car has the item
                            if (k == 0){
                                setTimeout(function(){
                                    if(item){
                                        item.position.z = car.position.z;
                                        item.position.x = car.position.x;
                                    }
                                }, 3000);
                            }
                            break;
                        }
                    }
                }

                // collision with good items (aka mushrooms)
                // we iterate over ALL the cars that can pass over one mushroom
                // for simplicity, only our car will do the sprint given by the item
                for (var k=0; k<carsAll.length; k++){
                    // collision car-goods: the car passes over a positive item (aka a mushroom), it will accelerate
                    for (i=0; i<goodItemPos.length; i++){
                        if(carsAll[k].position.x < goodItemPos[i][0]+0.8 && carsAll[k].position.x > goodItemPos[i][0]-0.8 && carsAll[k].position.z < goodItemPos[i][2]+0.8 && carsAll[k].position.z > goodItemPos[i][2]-0.8){
                            // our car
                            if (k == 0) {
                                // play the mushroom sound
                                const soundMush = new BABYLON.Sound("soundMush", "sounds/mushroom.mp3", scene, function(){
                                    soundMush.play();
                                });
                                var repeat = true;
                                soundMush.onended = function(){
                                    if (repeat){
                                        soundMush.play();
                                        repeat = false;
                                    }
                                }
                                
                                sprint = 1;
                            }

                            goodItems[i].dispose();
                            goodItems.splice(i, 1);
                            goodItemPos.splice(i, 1);

                            break;
                        }
                    }
                }

                // updating of the index checkpoint through the path
                if(index == 0){
                    index +=1;
                }
                else if (index == 1 || index >= 9){
                    if (car.position.z > ckpts[index].z) index +=1;
                }
                else if (index == 6 || index == 8){
                    if (car.position.x > ckpts[index].x) index +=1;
                }
                else if (index == 3 || index == 5 || index == 7){
                    if (car.position.z < ckpts[index].z) index +=1;
                }
                else if (index == 2 || index == 4){
                    if (car.position.x < ckpts[index].x) index +=1;
                }
                index = index % ckpts.length;
                
                wall1 = true;
                wall2 = true;
                wall3 = true;
                wall4 = true;
                wall5 = true;
                wall6 = true;
                wall7 = true;
                wall8 = true;

                // collision car-walls: fall down of the track
                // check where the car is
                if (car.position.x > 634 && car.position.x < 666.3 && car.position.z < 320 && car.position.z > -463) wall1 = false;
                if (car.position.x > 387 && car.position.x < 666.3 && car.position.z < 320 && car.position.z > 288.5) wall2 = false;
                if (car.position.x > 387 && car.position.x < 419 && car.position.z < 320 && car.position.z > 22.5) wall3 = false;
                if (car.position.x > 140 && car.position.x < 419 && car.position.z < 54.7 && car.position.z > 22.5) wall4 = false;
                if (car.position.x > 140 && car.position.x < 171.9 && car.position.z < 54.7 && car.position.z > -186.4) wall5 = false;
                if (car.position.x > 140 && car.position.x < 419 && car.position.z < -154.3 && car.position.z > -186.4) wall6 = false;
                if (car.position.x > 387 && car.position.x < 419 && car.position.z < -154.3 && car.position.z > -463) wall7 = false;
                if (car.position.x > 387 && car.position.x < 666.3 && car.position.z < -432.4 && car.position.z > -463) wall8 = false;

                // falling down routine
                if (doAnim&&wall1&&wall2&&wall3&&wall4&&wall5&&wall6&&wall7&&wall8){
                    doAnim = false;

                    if (pos  == true){
                        posX = car.position.x;
                        posY = car.position.y;
                        posZ = car.position.z;
                        pos = false;
                    }

                    var animationBurnX = new BABYLON.Animation("burnX", "position.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    var animationBurnY = new BABYLON.Animation("burnX", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    var animationBurnZ = new BABYLON.Animation("burnX", "position.z", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    
                    var keysX = [{ "frame": 0, "value": posX }, { "frame": 30, "value": (posX+ckpts[index-1].x) / 2 },{ "frame": 60, "value": ckpts[index-1].x }];
                    var keysY = [{ "frame": 0, "value": posY }, { "frame": 30, "value": posY + 20 },{ "frame": 60, "value": ckpts[index-1].y }];
                    var keysZ = [{ "frame": 0, "value": posZ }, { "frame": 30, "value": (posZ+ckpts[index-1].z) / 2 },{ "frame": 60, "value": ckpts[index-1].z }];

                    animationBurnX.setKeys(keysX);
                    animationBurnY.setKeys(keysY);
                    animationBurnZ.setKeys(keysZ);

                    var animBurn = scene.beginDirectAnimation(car, [animationBurnX, animationBurnY, animationBurnZ], 0, 60, false);

                    if (s == true){
                        soundBurn = new BABYLON.Sound("soundBurn", "sounds/sm64_mario_burned.wav", scene, function(){
                            soundBurn.play();
                            s = false;
                        });
                    }

                    var endWorldTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                    var textBlock = new BABYLON.GUI.TextBlock("text", '');   
                    textBlock.color = "orange";
                    textBlock.fontSize = 100;
                    textBlock.fontFamily = "impact";
                    endWorldTexture.addControl(textBlock);
                    textBlock.text = "You have been burnt by the lava..\n Try to stay on the track!";
                    var handle = window.setInterval(() => {
                        window.clearInterval(handle);
                        textBlock.dispose();
                        endWorldTexture.dispose();
                    }, 3000);
                    
                    animBurn.onAnimationEnd = function () {

                        car.position.x = ckpts[index-1].x;
                        car.position.y = ckpts[index-1].y;
                        car.position.z = ckpts[index-1].z;
                        car.rotation.y = ckpts[index-1].w;
                        acceleration = -0.5;

                        // you lose the item if you fall down
                        if (item) {
                            item.dispose();
                            item = null;
                        }
                        // we do not consider the progress of checkpoints if we fall
                        //index = (index - 1) % (ckpts.length - 1);
                        s = true;
                        pos = true;
                        doAnim = true;
                    }
                    
                }

                // control overtakings:
                // 1) we actively overtake
                for (var k=0; k<carsFront.length; k++){
                    if(carsFront[k].lap <= lap && carsFront[k].half_lap == half_lap){
                        if (!wall1) {
                            if (car.position.z > carsFront[k].position.z && carsFront[k].position.x > 634 && carsFront[k].position.x < 663){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall2) {
                            if (car.position.x < carsFront[k].position.x && carsFront[k].position.z > 288.5 && carsFront[k].position.z < 320){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall3) {
                            if (car.position.z < carsFront[k].position.z && carsFront[k].position.x > 387 && carsFront[k].position.x < 419){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall4) {
                            if (car.position.x < carsFront[k].position.x && carsFront[k].position.z > 22.5 && carsFront[k].position.z < 54.7){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall5) {
                            if (car.position.z < carsFront[k].position.z && carsFront[k].position.x > 140 && carsFront[k].position.x < 171.9){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall6) {
                            if (car.position.x > carsFront[k].position.x && carsFront[k].position.z > -186.4 && carsFront[k].position.z < -154.3){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall7) {
                            if (car.position.z < carsFront[k].position.z && carsFront[k].position.x > 387 && carsFront[k].position.x < 419){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall8) {
                            if (car.position.x > carsFront[k].position.x && carsFront[k].position.z > -463 && carsFront[k].position.x < -432.4){
                                car_overTaken = carsFront.splice(k, 1);
                                carsBehind.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                    }
                }
                // 2) we are passively overtaken
                for (var k=0; k<carsBehind.length; k++){
                    if(carsBehind[k].lap == lap && carsBehind[k].half_lap == half_lap){
                        if (!wall1) {
                            if (car.position.z < carsBehind[k].position.z && carsBehind[k].position.x > 634 && carsBehind[k].position.x < 663){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall2) {
                            if (car.position.x > carsBehind[k].position.x && carsBehind[k].position.z > 288.5 && carsBehind[k].position.z < 320){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall3) {
                            if (car.position.z > carsBehind[k].position.z && carsBehind[k].position.x > 387 && carsBehind[k].position.x < 419){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall4) {
                            if (car.position.x > carsBehind[k].position.x && carsBehind[k].position.z > 22.5 && carsBehind[k].position.z < 54.7){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall5) {
                            if (car.position.z > carsBehind[k].position.z && carsBehind[k].position.x > 140 && carsBehind[k].position.x < 171.9){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall6) {
                            if (car.position.x < carsBehind[k].position.x && carsBehind[k].position.z > -186.4 && carsBehind[k].position.z < -154.3){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall7) {
                            if (car.position.z > carsBehind[k].position.z && carsBehind[k].position.x > 387 && carsBehind[k].position.x < 419){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                        else if (!wall8) {
                            if (car.position.x < carsBehind[k].position.x && carsBehind[k].position.z > -463 && carsBehind[k].position.x < -432.4){
                                car_overTaken = carsBehind.splice(k, 1);
                                carsFront.push(car_overTaken[0]);

                                x2.text = 'Position: ' + String(carsFront.length + 1);
                            }
                        }
                    }
                }

                // game loop
                if(lap <= 3){
                    // car's movement update
                    car.position.z += (base_speed + acceleration + sprint) * Math.cos(angle);
                    car.position.x += (base_speed + acceleration + sprint) * Math.sin(angle);

                    // wheels' animation
                    wheelFL.rotate(BABYLON.Axis.Y, (base_speed + acceleration + sprint)/3, BABYLON.Space.LOCAL);
                    wheelFR.rotate(BABYLON.Axis.Y, (base_speed + acceleration + sprint)/3, BABYLON.Space.LOCAL);
                    wheelRL.rotate(BABYLON.Axis.Y, (base_speed + acceleration + sprint)/3, BABYLON.Space.LOCAL);
                    wheelRR.rotate(BABYLON.Axis.Y, (base_speed + acceleration + sprint)/3, BABYLON.Space.LOCAL);

                    // item's movement update
                    if(item){
                        if(throwed == 0){
                            item.position.z += (base_speed + acceleration + throwed + sprint) * Math.cos(angle);
                            item.position.x += (base_speed + acceleration + throwed + sprint) * Math.sin(angle);
                            // saved to throw shell in the right direction
                            last_angle = angle;
                        }
                        else{
                            item.position.z += (base_speed + acceleration + throwed + sprint) * Math.cos(last_angle);
                            item.position.x += (base_speed + acceleration + throwed + sprint) * Math.sin(last_angle);
                        }
                                      
                    }
                    // trick to gradually reduce the sprint of a mushroom
                    if (sprint > 0) sprint -= 0.002;

                    angle = car.rotation.y - Math.PI;
                    
                    // You must arrive to half lap to increase lap when you arrive to the finish line
                    if (car.position.z < -65 && car.position.z > -70 && car.position.x > 140 && car.position.x < 172){
                        half_lap = true;
                        car.rotation.y = Math.PI*2;
                    }

                    // lap's increment and update
                    if(half_lap && car.position.z <153 && car.position.z >150 && car.position.x < 666.3 && car.position.x > 634){
                        if(lap <=2){
                            var lapTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                            var textBlock = new BABYLON.GUI.TextBlock("text", new String(i));   
                            textBlock.color = "orange";
                            textBlock.fontSize = 150;
                            textBlock.fontFamily = "impact";
                            lapTexture.addControl(textBlock);
                            textBlock.text = "LAP " + String(lap) + " FINISHED!";
                            var handle = window.setInterval(() => {
                                window.clearInterval(handle);
                                textBlock.dispose();
                                lapTexture.dispose();
                            }, 3000);

                            if(lap <= 1){
                                soundLap = new BABYLON.Sound("soundStart", "sounds/lap.mp3", scene, function(){
                                    bowserSound.pause();
                                    soundLap.play();
                                });
                                soundLap.onended = function(){
                                    bowserSound.play();
                                }
                            }
                            else{
                                soundFinalLap = new BABYLON.Sound("soundStart", "sounds/final_lap.mp3", scene, function(){
                                    bowserSound.pause();
                                    soundFinalLap.play();
                                });
                                soundFinalLap.onended = function(){
                                    bowserSound.play();
                                }
                            }
                            x1.text = 'Lap ' + String(lap) + '/3' + '\n Time: ' + String(raceTime);
                        }
                        lap += 1;
                        car.rotation.y = Math.PI;
                        half_lap = false;
                    }
                    var speed = base_speed + acceleration + sprint;

                    // cpu lap
                    if (car1.position.z < -65 && car1.position.z > -70 && car1.position.x > 140 && car1.position.x < 172)
                        car1.half_lap = true;
                    if (car2.position.z < -65 && car2.position.z > -70 && car2.position.x > 140 && car2.position.x < 172)
                        car2.half_lap = true;
                    if (car3.position.z < -65 && car3.position.z > -70 && car3.position.x > 140 && car3.position.x < 172)
                        car3.half_lap = true;
                    
                    if(car1.half_lap && car1.position.z <153 && car1.position.z >150 && car1.position.x < 666.3 && car1.position.x > 634){
                        car1.half_lap = false;
                        car1.lap += 1;
                    }
                    if(car2.half_lap && car2.position.z <153 && car2.position.z >150 && car2.position.x < 666.3 && car2.position.x > 634){
                        car2.half_lap = false;
                        car2.lap += 1;
                    }
                    if(car3.half_lap && car3.position.z <153 && car3.position.z >150 && car3.position.x < 666.3 && car3.position.x > 634){
                        car3.half_lap = false;
                        car3.lap += 1;
                    }
                }
                // end game
                else{
                    if (speed > 0){
                        speed -= 0.002;
                        car.position.z += speed * Math.cos(angle);
                        car.position.x += speed * Math.sin(angle);
                    }
                    if(!update_done){
                        update_done = true;
                        const soundEnd = new BABYLON.Sound("soundEnd", "sounds/results.mp3", scene, function(){
                        bowserSound.stop();
                        soundEnd.play();
                        });
                        endGame();
                    }
                }
            });

            // controls
            scene.onKeyboardObservable.add((kbInfo) => {
                switch (kbInfo.type) {
                    case BABYLON.KeyboardEventTypes.KEYDOWN:
                        switch (kbInfo.event.key) {
                            case "a":
                            case "A":
                                car.rotation.y -= Math.PI / 18;
                                acceleration = 0;
                                break;

                            case "d":
                            case "D":
                                car.rotation.y += Math.PI / 18;
                                acceleration = 0;
                                break;

                            case "w":
                            case "W":
                                acceleration = 0.2;
                                break;

                            case "s":
                            case "S":
                                acceleration = -0.2;
                                break;

                            case "e":
                            case "E":
                                /* Items Usage
                                 * little recap on how items work on our Mario Kart:
                                 * - banana: if you use this object you will leave a banane peel on the race track
                                 *              where enemies (or even yourself!) can trip and spin
                                 * - red shell: if used and if there are enemies in front of you, it will follow and hit one of them
                                 *                  otherwise, it will act like a green shell
                                 * - green shell: if used, it follows a straight line trajectory and can hit enemies if encountered
                                 *   (N.B. the collisions with shells on a straight line have been held above together with the other lethal items)
                                 * - mushroom: it is the only good items here, if used, it will give a huge sprint for some seconds
                                 * 
                                 * Let's implement these characteristics.
                                */
                                if (item && (item.position.y == 4 || item.position.y == 4.5)){
                                    if(this.item_name == 'banana'){
                                        const soundDrop = new BABYLON.Sound("soundDrop", "sounds/mk64_banana.wav", scene, function(){
                                            soundDrop.play();
                                        });
                                        item.position.y = 0.95;
                                        posx = item.position.x;
                                        posy = item.position.y;
                                        posz = item.position.z;                  
                                        lethalItems.push(item);
                                        item = null;
                                        
                                        // this makes the item handling works: if we leave an item because we
                                        // hit another item box, we can set this interval to move far away from
                                        // the item and to not be hitten by it
                                        setTimeout(function(){
                                            lethalItemPos.push([posx, posy, posz])
                                        }, 500);

                                    }
                                    else if (this.item_name == 'red_shell'){
                                        const soundShell = new BABYLON.Sound("soundShell", "sounds/shell.mp3", scene, function(){
                                            soundShell.play();
                                        });
                                        item.position.y = 0.95;
                                        throwed = 1.8;
                                        
                                        // for simplificity we will hit the first car in front of us
                                        targetCar = carsFront[0];
                                        // we need that the shell reduces its distance from targetCar
                                        if (targetCar){
                                            // moreover we will position the red shell aligned to the target car, in this way it will always
                                            // go straight but it will ALMOST certainly hit the car
                                            // N.B. this is another further simplification but it is more easy to implement
                                            if (wall1||wall3||wall5||wall7) item.position.x = targetCar.position.x;
                                            else item.position.z = targetCar.position.z;
                                        }
                                    }
                                    else if (this.item_name == 'green_shell'){
                                        const soundShell = new BABYLON.Sound("soundShell", "sounds/shell.mp3", scene, function(){
                                            soundShell.play();
                                        });
                                        item.position.y = 0.95;
                                        throwed = 1.8;
                                    }
                                    else if (this.item_name == 'mushroom'){
                                        const soundMush = new BABYLON.Sound("soundMush", "sounds/mushroom.mp3", scene, function(){
                                            soundMush.play();
                                        });
                                        var repeat = true;
                                        soundMush.onended = function(){
                                            if (repeat){
                                                soundMush.play();
                                                repeat = false;
                                            }
                                        }
                                        sprint = 0.7;
                                        item.dispose();
                                        item = null;
                                    }
                                }
                                break;

                            case "r":
                            case "R":
                                window.location.reload()
                                break;

                            case "c":
                            case "C":
                                if(game_ended){
                                    if(parent.document.URL.indexOf('&') > 1)
                                        window.location.href = "rainbowRoad.html?character="+character_name+"&score="+score.toString();
                                    else
                                        window.location.href = "index.html";
                                }
                                break;  

                            default:
                                acceleration = 0;
                        }
                    break;
                }
            });
        }
        
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>
